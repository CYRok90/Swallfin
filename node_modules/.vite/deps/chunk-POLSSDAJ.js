import {
  CUSTOM_FORMATTING_SETTINGS_CONTEXT_KEY
} from "./chunk-U7DPTAY4.js";
import {
  getContext
} from "./chunk-SQSKWABO.js";
import {
  __commonJS,
  __toESM
} from "./chunk-VSE7GGL6.js";

// ../../node_modules/ssf/ssf.js
var require_ssf = __commonJS({
  "../../node_modules/ssf/ssf.js"(exports, module) {
    var SSF = {};
    var make_ssf = function make_ssf2(SSF2) {
      SSF2.version = "0.11.2";
      function _strrev(x) {
        var o = "", i = x.length - 1;
        while (i >= 0) o += x.charAt(i--);
        return o;
      }
      function fill2(c, l) {
        var o = "";
        while (o.length < l) o += c;
        return o;
      }
      function pad0(v, d) {
        var t = "" + v;
        return t.length >= d ? t : fill2("0", d - t.length) + t;
      }
      function pad_(v, d) {
        var t = "" + v;
        return t.length >= d ? t : fill2(" ", d - t.length) + t;
      }
      function rpad_(v, d) {
        var t = "" + v;
        return t.length >= d ? t : t + fill2(" ", d - t.length);
      }
      function pad0r1(v, d) {
        var t = "" + Math.round(v);
        return t.length >= d ? t : fill2("0", d - t.length) + t;
      }
      function pad0r2(v, d) {
        var t = "" + v;
        return t.length >= d ? t : fill2("0", d - t.length) + t;
      }
      var p2_32 = Math.pow(2, 32);
      function pad0r(v, d) {
        if (v > p2_32 || v < -p2_32) return pad0r1(v, d);
        var i = Math.round(v);
        return pad0r2(i, d);
      }
      function isgeneral(s, i) {
        i = i || 0;
        return s.length >= 7 + i && (s.charCodeAt(i) | 32) === 103 && (s.charCodeAt(i + 1) | 32) === 101 && (s.charCodeAt(i + 2) | 32) === 110 && (s.charCodeAt(i + 3) | 32) === 101 && (s.charCodeAt(i + 4) | 32) === 114 && (s.charCodeAt(i + 5) | 32) === 97 && (s.charCodeAt(i + 6) | 32) === 108;
      }
      var days = [
        ["Sun", "Sunday"],
        ["Mon", "Monday"],
        ["Tue", "Tuesday"],
        ["Wed", "Wednesday"],
        ["Thu", "Thursday"],
        ["Fri", "Friday"],
        ["Sat", "Saturday"]
      ];
      var months = [
        ["J", "Jan", "January"],
        ["F", "Feb", "February"],
        ["M", "Mar", "March"],
        ["A", "Apr", "April"],
        ["M", "May", "May"],
        ["J", "Jun", "June"],
        ["J", "Jul", "July"],
        ["A", "Aug", "August"],
        ["S", "Sep", "September"],
        ["O", "Oct", "October"],
        ["N", "Nov", "November"],
        ["D", "Dec", "December"]
      ];
      function init_table(t) {
        t[0] = "General";
        t[1] = "0";
        t[2] = "0.00";
        t[3] = "#,##0";
        t[4] = "#,##0.00";
        t[9] = "0%";
        t[10] = "0.00%";
        t[11] = "0.00E+00";
        t[12] = "# ?/?";
        t[13] = "# ??/??";
        t[14] = "m/d/yy";
        t[15] = "d-mmm-yy";
        t[16] = "d-mmm";
        t[17] = "mmm-yy";
        t[18] = "h:mm AM/PM";
        t[19] = "h:mm:ss AM/PM";
        t[20] = "h:mm";
        t[21] = "h:mm:ss";
        t[22] = "m/d/yy h:mm";
        t[37] = "#,##0 ;(#,##0)";
        t[38] = "#,##0 ;[Red](#,##0)";
        t[39] = "#,##0.00;(#,##0.00)";
        t[40] = "#,##0.00;[Red](#,##0.00)";
        t[45] = "mm:ss";
        t[46] = "[h]:mm:ss";
        t[47] = "mmss.0";
        t[48] = "##0.0E+0";
        t[49] = "@";
        t[56] = '"上午/下午 "hh"時"mm"分"ss"秒 "';
      }
      var table_fmt = {};
      init_table(table_fmt);
      var default_map = [];
      var defi = 0;
      for (defi = 5; defi <= 8; ++defi) default_map[defi] = 32 + defi;
      for (defi = 23; defi <= 26; ++defi) default_map[defi] = 0;
      for (defi = 27; defi <= 31; ++defi) default_map[defi] = 14;
      for (defi = 50; defi <= 58; ++defi) default_map[defi] = 14;
      for (defi = 59; defi <= 62; ++defi) default_map[defi] = defi - 58;
      for (defi = 67; defi <= 68; ++defi) default_map[defi] = defi - 58;
      for (defi = 72; defi <= 75; ++defi) default_map[defi] = defi - 58;
      for (defi = 67; defi <= 68; ++defi) default_map[defi] = defi - 57;
      for (defi = 76; defi <= 78; ++defi) default_map[defi] = defi - 56;
      for (defi = 79; defi <= 81; ++defi) default_map[defi] = defi - 34;
      var default_str = [];
      default_str[5] = default_str[63] = '"$"#,##0_);\\("$"#,##0\\)';
      default_str[6] = default_str[64] = '"$"#,##0_);[Red]\\("$"#,##0\\)';
      default_str[7] = default_str[65] = '"$"#,##0.00_);\\("$"#,##0.00\\)';
      default_str[8] = default_str[66] = '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)';
      default_str[41] = '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)';
      default_str[42] = '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)';
      default_str[43] = '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)';
      default_str[44] = '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)';
      function frac(x, D, mixed) {
        var sgn = x < 0 ? -1 : 1;
        var B = x * sgn;
        var P_2 = 0, P_1 = 1, P = 0;
        var Q_2 = 1, Q_1 = 0, Q = 0;
        var A = Math.floor(B);
        while (Q_1 < D) {
          A = Math.floor(B);
          P = A * P_1 + P_2;
          Q = A * Q_1 + Q_2;
          if (B - A < 5e-8) break;
          B = 1 / (B - A);
          P_2 = P_1;
          P_1 = P;
          Q_2 = Q_1;
          Q_1 = Q;
        }
        if (Q > D) {
          if (Q_1 > D) {
            Q = Q_2;
            P = P_2;
          } else {
            Q = Q_1;
            P = P_1;
          }
        }
        if (!mixed) return [0, sgn * P, Q];
        var q = Math.floor(sgn * P / Q);
        return [q, sgn * P - q * Q, Q];
      }
      function parse_date_code(v, opts, b2) {
        if (v > 2958465 || v < 0) return null;
        var date = v | 0, time = Math.floor(86400 * (v - date)), dow = 0;
        var dout = [];
        var out = { D: date, T: time, u: 86400 * (v - date) - time, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
        if (Math.abs(out.u) < 1e-6) out.u = 0;
        if (opts && opts.date1904) date += 1462;
        if (out.u > 0.9999) {
          out.u = 0;
          if (++time == 86400) {
            out.T = time = 0;
            ++date;
            ++out.D;
          }
        }
        if (date === 60) {
          dout = b2 ? [1317, 10, 29] : [1900, 2, 29];
          dow = 3;
        } else if (date === 0) {
          dout = b2 ? [1317, 8, 29] : [1900, 1, 0];
          dow = 6;
        } else {
          if (date > 60) --date;
          var d = new Date(1900, 0, 1);
          d.setDate(d.getDate() + date - 1);
          dout = [d.getFullYear(), d.getMonth() + 1, d.getDate()];
          dow = d.getDay();
          if (date < 60) dow = (dow + 6) % 7;
          if (b2) dow = fix_hijri(d, dout);
        }
        out.y = dout[0];
        out.m = dout[1];
        out.d = dout[2];
        out.S = time % 60;
        time = Math.floor(time / 60);
        out.M = time % 60;
        time = Math.floor(time / 60);
        out.H = time;
        out.q = dow;
        return out;
      }
      SSF2.parse_date_code = parse_date_code;
      var basedate = new Date(1899, 11, 31, 0, 0, 0);
      var dnthresh = basedate.getTime();
      var base1904 = new Date(1900, 2, 1, 0, 0, 0);
      function datenum_local(v, date1904) {
        var epoch = v.getTime();
        if (date1904) epoch -= 1461 * 24 * 60 * 60 * 1e3;
        else if (v >= base1904) epoch += 24 * 60 * 60 * 1e3;
        return (epoch - (dnthresh + (v.getTimezoneOffset() - basedate.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
      }
      function general_fmt_int(v) {
        return v.toString(10);
      }
      SSF2._general_int = general_fmt_int;
      var general_fmt_num = /* @__PURE__ */ function make_general_fmt_num() {
        var trailing_zeroes_and_decimal = /(?:\.0*|(\.\d*[1-9])0+)$/;
        function strip_decimal(o) {
          return o.indexOf(".") == -1 ? o : o.replace(trailing_zeroes_and_decimal, "$1");
        }
        var mantissa_zeroes_and_decimal = /(?:\.0*|(\.\d*[1-9])0+)[Ee]/;
        var exp_with_single_digit = /(E[+-])(\d)$/;
        function normalize_exp(o) {
          if (o.indexOf("E") == -1) return o;
          return o.replace(mantissa_zeroes_and_decimal, "$1E").replace(exp_with_single_digit, "$10$2");
        }
        function small_exp(v) {
          var w = v < 0 ? 12 : 11;
          var o = strip_decimal(v.toFixed(12));
          if (o.length <= w) return o;
          o = v.toPrecision(10);
          if (o.length <= w) return o;
          return v.toExponential(5);
        }
        function large_exp(v) {
          var o = strip_decimal(v.toFixed(11));
          return o.length > (v < 0 ? 12 : 11) || o === "0" || o === "-0" ? v.toPrecision(6) : o;
        }
        function general_fmt_num_base(v) {
          var V = Math.floor(Math.log(Math.abs(v)) * Math.LOG10E), o;
          if (V >= -4 && V <= -1) o = v.toPrecision(10 + V);
          else if (Math.abs(V) <= 9) o = small_exp(v);
          else if (V === 10) o = v.toFixed(10).substr(0, 12);
          else o = large_exp(v);
          return strip_decimal(normalize_exp(o.toUpperCase()));
        }
        return general_fmt_num_base;
      }();
      SSF2._general_num = general_fmt_num;
      function general_fmt(v, opts) {
        switch (typeof v) {
          case "string":
            return v;
          case "boolean":
            return v ? "TRUE" : "FALSE";
          case "number":
            return (v | 0) === v ? v.toString(10) : general_fmt_num(v);
          case "undefined":
            return "";
          case "object":
            if (v == null) return "";
            if (v instanceof Date) return format(14, datenum_local(v, opts && opts.date1904), opts);
        }
        throw new Error("unsupported value in General format: " + v);
      }
      SSF2._general = general_fmt;
      function fix_hijri(date, o) {
        o[0] -= 581;
        var dow = date.getDay();
        if (date < 60) dow = (dow + 6) % 7;
        return dow;
      }
      var THAI_DIGITS = "๐๑๒๓๔๕๖๗๘๙".split("");
      function write_date(type, fmt2, val, ss0) {
        var o = "", ss = 0, tt = 0, y = val.y, out, outl = 0;
        switch (type) {
          case 98:
            y = val.y + 543;
          case 121:
            switch (fmt2.length) {
              case 1:
              case 2:
                out = y % 100;
                outl = 2;
                break;
              default:
                out = y % 1e4;
                outl = 4;
                break;
            }
            break;
          case 109:
            switch (fmt2.length) {
              case 1:
              case 2:
                out = val.m;
                outl = fmt2.length;
                break;
              case 3:
                return months[val.m - 1][1];
              case 5:
                return months[val.m - 1][0];
              default:
                return months[val.m - 1][2];
            }
            break;
          case 100:
            switch (fmt2.length) {
              case 1:
              case 2:
                out = val.d;
                outl = fmt2.length;
                break;
              case 3:
                return days[val.q][0];
              default:
                return days[val.q][1];
            }
            break;
          case 104:
            switch (fmt2.length) {
              case 1:
              case 2:
                out = 1 + (val.H + 11) % 12;
                outl = fmt2.length;
                break;
              default:
                throw "bad hour format: " + fmt2;
            }
            break;
          case 72:
            switch (fmt2.length) {
              case 1:
              case 2:
                out = val.H;
                outl = fmt2.length;
                break;
              default:
                throw "bad hour format: " + fmt2;
            }
            break;
          case 77:
            switch (fmt2.length) {
              case 1:
              case 2:
                out = val.M;
                outl = fmt2.length;
                break;
              default:
                throw "bad minute format: " + fmt2;
            }
            break;
          case 115:
            if (fmt2 != "s" && fmt2 != "ss" && fmt2 != ".0" && fmt2 != ".00" && fmt2 != ".000") throw "bad second format: " + fmt2;
            if (val.u === 0 && (fmt2 == "s" || fmt2 == "ss")) return pad0(val.S, fmt2.length);
            if (ss0 >= 2) tt = ss0 === 3 ? 1e3 : 100;
            else tt = ss0 === 1 ? 10 : 1;
            ss = Math.round(tt * (val.S + val.u));
            if (ss >= 60 * tt) ss = 0;
            if (fmt2 === "s") return ss === 0 ? "0" : "" + ss / tt;
            o = pad0(ss, 2 + ss0);
            if (fmt2 === "ss") return o.substr(0, 2);
            return "." + o.substr(2, fmt2.length - 1);
          case 90:
            switch (fmt2) {
              case "[h]":
              case "[hh]":
                out = val.D * 24 + val.H;
                break;
              case "[m]":
              case "[mm]":
                out = (val.D * 24 + val.H) * 60 + val.M;
                break;
              case "[s]":
              case "[ss]":
                out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + Math.round(val.S + val.u);
                break;
              default:
                throw "bad abstime format: " + fmt2;
            }
            outl = fmt2.length === 3 ? 1 : 2;
            break;
          case 101:
            out = y;
            outl = 1;
            break;
        }
        var outstr = outl > 0 ? pad0(out, outl) : "";
        return outstr;
      }
      function commaify(s) {
        var w = 3;
        if (s.length <= w) return s;
        var j = s.length % w, o = s.substr(0, j);
        for (; j != s.length; j += w) o += (o.length > 0 ? "," : "") + s.substr(j, w);
        return o;
      }
      var write_num = /* @__PURE__ */ function make_write_num() {
        var pct1 = /%/g;
        function write_num_pct(type, fmt2, val) {
          var sfmt = fmt2.replace(pct1, ""), mul = fmt2.length - sfmt.length;
          return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill2("%", mul);
        }
        function write_num_cm(type, fmt2, val) {
          var idx = fmt2.length - 1;
          while (fmt2.charCodeAt(idx - 1) === 44) --idx;
          return write_num(type, fmt2.substr(0, idx), val / Math.pow(10, 3 * (fmt2.length - idx)));
        }
        function write_num_exp(fmt2, val) {
          var o;
          var idx = fmt2.indexOf("E") - fmt2.indexOf(".") - 1;
          if (fmt2.match(/^#+0.0E\+0$/)) {
            if (val == 0) return "0.0E+0";
            else if (val < 0) return "-" + write_num_exp(fmt2, -val);
            var period = fmt2.indexOf(".");
            if (period === -1) period = fmt2.indexOf("E");
            var ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
            if (ee < 0) ee += period;
            o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
            if (o.indexOf("e") === -1) {
              var fakee = Math.floor(Math.log(val) * Math.LOG10E);
              if (o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
              else o += "E+" + (fakee - ee);
              while (o.substr(0, 2) === "0.") {
                o = o.charAt(0) + o.substr(2, period) + "." + o.substr(2 + period);
                o = o.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
              }
              o = o.replace(/\+-/, "-");
            }
            o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
              return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
            });
          } else o = val.toExponential(idx);
          if (fmt2.match(/E\+00$/) && o.match(/e[+-]\d$/)) o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
          if (fmt2.match(/E\-/) && o.match(/e\+/)) o = o.replace(/e\+/, "e");
          return o.replace("e", "E");
        }
        var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
        function write_num_f1(r, aval, sign) {
          var den = parseInt(r[4], 10), rr = Math.round(aval * den), base = Math.floor(rr / den);
          var myn = rr - base * den, myd = den;
          return sign + (base === 0 ? "" : "" + base) + " " + (myn === 0 ? fill2(" ", r[1].length + 1 + r[4].length) : pad_(myn, r[1].length) + r[2] + "/" + r[3] + pad0(myd, r[4].length));
        }
        function write_num_f2(r, aval, sign) {
          return sign + (aval === 0 ? "" : "" + aval) + fill2(" ", r[1].length + 2 + r[4].length);
        }
        var dec1 = /^#*0*\.([0#]+)/;
        var closeparen = /\).*[0#]/;
        var phone = /\(###\) ###\\?-####/;
        function hashq(str) {
          var o = "", cc;
          for (var i = 0; i != str.length; ++i) switch (cc = str.charCodeAt(i)) {
            case 35:
              break;
            case 63:
              o += " ";
              break;
            case 48:
              o += "0";
              break;
            default:
              o += String.fromCharCode(cc);
          }
          return o;
        }
        function rnd(val, d) {
          var dd = Math.pow(10, d);
          return "" + Math.round(val * dd) / dd;
        }
        function dec(val, d) {
          var _frac = val - Math.floor(val), dd = Math.pow(10, d);
          if (d < ("" + Math.round(_frac * dd)).length) return 0;
          return Math.round(_frac * dd);
        }
        function carry(val, d) {
          if (d < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d))).length) {
            return 1;
          }
          return 0;
        }
        function flr(val) {
          if (val < 2147483647 && val > -2147483648) return "" + (val >= 0 ? val | 0 : val - 1 | 0);
          return "" + Math.floor(val);
        }
        function write_num_flt(type, fmt2, val) {
          if (type.charCodeAt(0) === 40 && !fmt2.match(closeparen)) {
            var ffmt = fmt2.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
            if (val >= 0) return write_num_flt("n", ffmt, val);
            return "(" + write_num_flt("n", ffmt, -val) + ")";
          }
          if (fmt2.charCodeAt(fmt2.length - 1) === 44) return write_num_cm(type, fmt2, val);
          if (fmt2.indexOf("%") !== -1) return write_num_pct(type, fmt2, val);
          if (fmt2.indexOf("E") !== -1) return write_num_exp(fmt2, val);
          if (fmt2.charCodeAt(0) === 36) return "$" + write_num_flt(type, fmt2.substr(fmt2.charAt(1) == " " ? 2 : 1), val);
          var o;
          var r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
          if (fmt2.match(/^00+$/)) return sign + pad0r(aval, fmt2.length);
          if (fmt2.match(/^[#?]+$/)) {
            o = pad0r(val, 0);
            if (o === "0") o = "";
            return o.length > fmt2.length ? o : hashq(fmt2.substr(0, fmt2.length - o.length)) + o;
          }
          if (r = fmt2.match(frac1)) return write_num_f1(r, aval, sign);
          if (fmt2.match(/^#+0+$/)) return sign + pad0r(aval, fmt2.length - fmt2.indexOf("0"));
          if (r = fmt2.match(dec1)) {
            o = rnd(val, r[1].length).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1])).replace(/\.(\d*)$/, function($$, $1) {
              return "." + $1 + fill2("0", hashq(r[1]).length - $1.length);
            });
            return fmt2.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
          }
          fmt2 = fmt2.replace(/^#+([0.])/, "$1");
          if (r = fmt2.match(/^(0*)\.(#*)$/)) {
            return sign + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
          }
          if (r = fmt2.match(/^#{1,3},##0(\.?)$/)) return sign + commaify(pad0r(aval, 0));
          if (r = fmt2.match(/^#,##0\.([#0]*0)$/)) {
            return val < 0 ? "-" + write_num_flt(type, fmt2, -val) : commaify("" + (Math.floor(val) + carry(val, r[1].length))) + "." + pad0(dec(val, r[1].length), r[1].length);
          }
          if (r = fmt2.match(/^#,#*,#0/)) return write_num_flt(type, fmt2.replace(/^#,#*,/, ""), val);
          if (r = fmt2.match(/^([0#]+)(\\?-([0#]+))+$/)) {
            o = _strrev(write_num_flt(type, fmt2.replace(/[\\-]/g, ""), val));
            ri = 0;
            return _strrev(_strrev(fmt2.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
              return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
            }));
          }
          if (fmt2.match(phone)) {
            o = write_num_flt(type, "##########", val);
            return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
          }
          var oa = "";
          if (r = fmt2.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
            ri = Math.min(r[4].length, 7);
            ff = frac(aval, Math.pow(10, ri) - 1, false);
            o = "" + sign;
            oa = write_num("n", r[1], ff[1]);
            if (oa.charAt(oa.length - 1) == " ") oa = oa.substr(0, oa.length - 1) + "0";
            o += oa + r[2] + "/" + r[3];
            oa = rpad_(ff[2], ri);
            if (oa.length < r[4].length) oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
            o += oa;
            return o;
          }
          if (r = fmt2.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
            ri = Math.min(Math.max(r[1].length, r[4].length), 7);
            ff = frac(aval, Math.pow(10, ri) - 1, true);
            return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill2(" ", 2 * ri + 1 + r[2].length + r[3].length));
          }
          if (r = fmt2.match(/^[#0?]+$/)) {
            o = pad0r(val, 0);
            if (fmt2.length <= o.length) return o;
            return hashq(fmt2.substr(0, fmt2.length - o.length)) + o;
          }
          if (r = fmt2.match(/^([#0?]+)\.([#0]+)$/)) {
            o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
            ri = o.indexOf(".");
            var lres = fmt2.indexOf(".") - ri, rres = fmt2.length - o.length - lres;
            return hashq(fmt2.substr(0, lres) + o + fmt2.substr(fmt2.length - rres));
          }
          if (r = fmt2.match(/^00,000\.([#0]*0)$/)) {
            ri = dec(val, r[1].length);
            return val < 0 ? "-" + write_num_flt(type, fmt2, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
              return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
            }) + "." + pad0(ri, r[1].length);
          }
          switch (fmt2) {
            case "###,##0.00":
              return write_num_flt(type, "#,##0.00", val);
            case "###,###":
            case "##,###":
            case "#,###":
              var x = commaify(pad0r(aval, 0));
              return x !== "0" ? sign + x : "";
            case "###,###.00":
              return write_num_flt(type, "###,##0.00", val).replace(/^0\./, ".");
            case "#,###.00":
              return write_num_flt(type, "#,##0.00", val).replace(/^0\./, ".");
            default:
          }
          throw new Error("unsupported format |" + fmt2 + "|");
        }
        function write_num_cm2(type, fmt2, val) {
          var idx = fmt2.length - 1;
          while (fmt2.charCodeAt(idx - 1) === 44) --idx;
          return write_num(type, fmt2.substr(0, idx), val / Math.pow(10, 3 * (fmt2.length - idx)));
        }
        function write_num_pct2(type, fmt2, val) {
          var sfmt = fmt2.replace(pct1, ""), mul = fmt2.length - sfmt.length;
          return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill2("%", mul);
        }
        function write_num_exp2(fmt2, val) {
          var o;
          var idx = fmt2.indexOf("E") - fmt2.indexOf(".") - 1;
          if (fmt2.match(/^#+0.0E\+0$/)) {
            if (val == 0) return "0.0E+0";
            else if (val < 0) return "-" + write_num_exp2(fmt2, -val);
            var period = fmt2.indexOf(".");
            if (period === -1) period = fmt2.indexOf("E");
            var ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
            if (ee < 0) ee += period;
            o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
            if (!o.match(/[Ee]/)) {
              var fakee = Math.floor(Math.log(val) * Math.LOG10E);
              if (o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
              else o += "E+" + (fakee - ee);
              o = o.replace(/\+-/, "-");
            }
            o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
              return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
            });
          } else o = val.toExponential(idx);
          if (fmt2.match(/E\+00$/) && o.match(/e[+-]\d$/)) o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
          if (fmt2.match(/E\-/) && o.match(/e\+/)) o = o.replace(/e\+/, "e");
          return o.replace("e", "E");
        }
        function write_num_int(type, fmt2, val) {
          if (type.charCodeAt(0) === 40 && !fmt2.match(closeparen)) {
            var ffmt = fmt2.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
            if (val >= 0) return write_num_int("n", ffmt, val);
            return "(" + write_num_int("n", ffmt, -val) + ")";
          }
          if (fmt2.charCodeAt(fmt2.length - 1) === 44) return write_num_cm2(type, fmt2, val);
          if (fmt2.indexOf("%") !== -1) return write_num_pct2(type, fmt2, val);
          if (fmt2.indexOf("E") !== -1) return write_num_exp2(fmt2, val);
          if (fmt2.charCodeAt(0) === 36) return "$" + write_num_int(type, fmt2.substr(fmt2.charAt(1) == " " ? 2 : 1), val);
          var o;
          var r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
          if (fmt2.match(/^00+$/)) return sign + pad0(aval, fmt2.length);
          if (fmt2.match(/^[#?]+$/)) {
            o = "" + val;
            if (val === 0) o = "";
            return o.length > fmt2.length ? o : hashq(fmt2.substr(0, fmt2.length - o.length)) + o;
          }
          if (r = fmt2.match(frac1)) return write_num_f2(r, aval, sign);
          if (fmt2.match(/^#+0+$/)) return sign + pad0(aval, fmt2.length - fmt2.indexOf("0"));
          if (r = fmt2.match(dec1)) {
            o = ("" + val).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1]));
            o = o.replace(/\.(\d*)$/, function($$, $1) {
              return "." + $1 + fill2("0", hashq(r[1]).length - $1.length);
            });
            return fmt2.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
          }
          fmt2 = fmt2.replace(/^#+([0.])/, "$1");
          if (r = fmt2.match(/^(0*)\.(#*)$/)) {
            return sign + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
          }
          if (r = fmt2.match(/^#{1,3},##0(\.?)$/)) return sign + commaify("" + aval);
          if (r = fmt2.match(/^#,##0\.([#0]*0)$/)) {
            return val < 0 ? "-" + write_num_int(type, fmt2, -val) : commaify("" + val) + "." + fill2("0", r[1].length);
          }
          if (r = fmt2.match(/^#,#*,#0/)) return write_num_int(type, fmt2.replace(/^#,#*,/, ""), val);
          if (r = fmt2.match(/^([0#]+)(\\?-([0#]+))+$/)) {
            o = _strrev(write_num_int(type, fmt2.replace(/[\\-]/g, ""), val));
            ri = 0;
            return _strrev(_strrev(fmt2.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
              return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
            }));
          }
          if (fmt2.match(phone)) {
            o = write_num_int(type, "##########", val);
            return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
          }
          var oa = "";
          if (r = fmt2.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
            ri = Math.min(r[4].length, 7);
            ff = frac(aval, Math.pow(10, ri) - 1, false);
            o = "" + sign;
            oa = write_num("n", r[1], ff[1]);
            if (oa.charAt(oa.length - 1) == " ") oa = oa.substr(0, oa.length - 1) + "0";
            o += oa + r[2] + "/" + r[3];
            oa = rpad_(ff[2], ri);
            if (oa.length < r[4].length) oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
            o += oa;
            return o;
          }
          if (r = fmt2.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
            ri = Math.min(Math.max(r[1].length, r[4].length), 7);
            ff = frac(aval, Math.pow(10, ri) - 1, true);
            return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill2(" ", 2 * ri + 1 + r[2].length + r[3].length));
          }
          if (r = fmt2.match(/^[#0?]+$/)) {
            o = "" + val;
            if (fmt2.length <= o.length) return o;
            return hashq(fmt2.substr(0, fmt2.length - o.length)) + o;
          }
          if (r = fmt2.match(/^([#0]+)\.([#0]+)$/)) {
            o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
            ri = o.indexOf(".");
            var lres = fmt2.indexOf(".") - ri, rres = fmt2.length - o.length - lres;
            return hashq(fmt2.substr(0, lres) + o + fmt2.substr(fmt2.length - rres));
          }
          if (r = fmt2.match(/^00,000\.([#0]*0)$/)) {
            return val < 0 ? "-" + write_num_int(type, fmt2, -val) : commaify("" + val).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
              return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
            }) + "." + pad0(0, r[1].length);
          }
          switch (fmt2) {
            case "###,###":
            case "##,###":
            case "#,###":
              var x = commaify("" + aval);
              return x !== "0" ? sign + x : "";
            default:
              if (fmt2.match(/\.[0#?]*$/)) return write_num_int(type, fmt2.slice(0, fmt2.lastIndexOf(".")), val) + hashq(fmt2.slice(fmt2.lastIndexOf(".")));
          }
          throw new Error("unsupported format |" + fmt2 + "|");
        }
        return function write_num2(type, fmt2, val) {
          return (val | 0) === val ? write_num_int(type, fmt2, val) : write_num_flt(type, fmt2, val);
        };
      }();
      function split_fmt(fmt2) {
        var out = [];
        var in_str = false;
        for (var i = 0, j = 0; i < fmt2.length; ++i) switch (
          /*cc=*/
          fmt2.charCodeAt(i)
        ) {
          case 34:
            in_str = !in_str;
            break;
          case 95:
          case 42:
          case 92:
            ++i;
            break;
          case 59:
            out[out.length] = fmt2.substr(j, i - j);
            j = i + 1;
        }
        out[out.length] = fmt2.substr(j);
        if (in_str === true) throw new Error("Format |" + fmt2 + "| unterminated string ");
        return out;
      }
      SSF2._split = split_fmt;
      var abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
      function fmt_is_date(fmt2) {
        var i = 0, c = "", o = "";
        while (i < fmt2.length) {
          switch (c = fmt2.charAt(i)) {
            case "G":
              if (isgeneral(fmt2, i)) i += 6;
              i++;
              break;
            case '"':
              for (
                ;
                /*cc=*/
                fmt2.charCodeAt(++i) !== 34 && i < fmt2.length;
              ) {
              }
              ++i;
              break;
            case "\\":
              i += 2;
              break;
            case "_":
              i += 2;
              break;
            case "@":
              ++i;
              break;
            case "B":
            case "b":
              if (fmt2.charAt(i + 1) === "1" || fmt2.charAt(i + 1) === "2") return true;
            case "M":
            case "D":
            case "Y":
            case "H":
            case "S":
            case "E":
            case "m":
            case "d":
            case "y":
            case "h":
            case "s":
            case "e":
            case "g":
              return true;
            case "A":
            case "a":
            case "上":
              if (fmt2.substr(i, 3).toUpperCase() === "A/P") return true;
              if (fmt2.substr(i, 5).toUpperCase() === "AM/PM") return true;
              if (fmt2.substr(i, 5).toUpperCase() === "上午/下午") return true;
              ++i;
              break;
            case "[":
              o = c;
              while (fmt2.charAt(i++) !== "]" && i < fmt2.length) o += fmt2.charAt(i);
              if (o.match(abstime)) return true;
              break;
            case ".":
            case "0":
            case "#":
              while (i < fmt2.length && ("0#?.,E+-%".indexOf(c = fmt2.charAt(++i)) > -1 || c == "\\" && fmt2.charAt(i + 1) == "-" && "0#".indexOf(fmt2.charAt(i + 2)) > -1)) {
              }
              break;
            case "?":
              while (fmt2.charAt(++i) === c) {
              }
              break;
            case "*":
              ++i;
              if (fmt2.charAt(i) == " " || fmt2.charAt(i) == "*") ++i;
              break;
            case "(":
            case ")":
              ++i;
              break;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              while (i < fmt2.length && "0123456789".indexOf(fmt2.charAt(++i)) > -1) {
              }
              break;
            case " ":
              ++i;
              break;
            default:
              ++i;
              break;
          }
        }
        return false;
      }
      SSF2.is_date = fmt_is_date;
      function eval_fmt(fmt2, v, opts, flen) {
        var out = [], o = "", i = 0, c = "", lst = "t", dt, j, cc;
        var hr = "H";
        while (i < fmt2.length) {
          switch (c = fmt2.charAt(i)) {
            case "G":
              if (!isgeneral(fmt2, i)) throw new Error("unrecognized character " + c + " in " + fmt2);
              out[out.length] = { t: "G", v: "General" };
              i += 7;
              break;
            case '"':
              for (o = ""; (cc = fmt2.charCodeAt(++i)) !== 34 && i < fmt2.length; ) o += String.fromCharCode(cc);
              out[out.length] = { t: "t", v: o };
              ++i;
              break;
            case "\\":
              var w = fmt2.charAt(++i), t = w === "(" || w === ")" ? w : "t";
              out[out.length] = { t, v: w };
              ++i;
              break;
            case "_":
              out[out.length] = { t: "t", v: " " };
              i += 2;
              break;
            case "@":
              out[out.length] = { t: "T", v };
              ++i;
              break;
            case "B":
            case "b":
              if (fmt2.charAt(i + 1) === "1" || fmt2.charAt(i + 1) === "2") {
                if (dt == null) {
                  dt = parse_date_code(v, opts, fmt2.charAt(i + 1) === "2");
                  if (dt == null) return "";
                }
                out[out.length] = { t: "X", v: fmt2.substr(i, 2) };
                lst = c;
                i += 2;
                break;
              }
            case "M":
            case "D":
            case "Y":
            case "H":
            case "S":
            case "E":
              c = c.toLowerCase();
            case "m":
            case "d":
            case "y":
            case "h":
            case "s":
            case "e":
            case "g":
              if (v < 0) return "";
              if (dt == null) {
                dt = parse_date_code(v, opts);
                if (dt == null) return "";
              }
              o = c;
              while (++i < fmt2.length && fmt2.charAt(i).toLowerCase() === c) o += c;
              if (c === "m" && lst.toLowerCase() === "h") c = "M";
              if (c === "h") c = hr;
              out[out.length] = { t: c, v: o };
              lst = c;
              break;
            case "A":
            case "a":
            case "上":
              var q = { t: c, v: c };
              if (dt == null) dt = parse_date_code(v, opts);
              if (fmt2.substr(i, 3).toUpperCase() === "A/P") {
                if (dt != null) q.v = dt.H >= 12 ? "P" : "A";
                q.t = "T";
                hr = "h";
                i += 3;
              } else if (fmt2.substr(i, 5).toUpperCase() === "AM/PM") {
                if (dt != null) q.v = dt.H >= 12 ? "PM" : "AM";
                q.t = "T";
                i += 5;
                hr = "h";
              } else if (fmt2.substr(i, 5).toUpperCase() === "上午/下午") {
                if (dt != null) q.v = dt.H >= 12 ? "下午" : "上午";
                q.t = "T";
                i += 5;
                hr = "h";
              } else {
                q.t = "t";
                ++i;
              }
              if (dt == null && q.t === "T") return "";
              out[out.length] = q;
              lst = c;
              break;
            case "[":
              o = c;
              while (fmt2.charAt(i++) !== "]" && i < fmt2.length) o += fmt2.charAt(i);
              if (o.slice(-1) !== "]") throw 'unterminated "[" block: |' + o + "|";
              if (o.match(abstime)) {
                if (dt == null) {
                  dt = parse_date_code(v, opts);
                  if (dt == null) return "";
                }
                out[out.length] = { t: "Z", v: o.toLowerCase() };
                lst = o.charAt(1);
              } else if (o.indexOf("$") > -1) {
                o = (o.match(/\$([^-\[\]]*)/) || [])[1] || "$";
                if (!fmt_is_date(fmt2)) out[out.length] = { t: "t", v: o };
              }
              break;
            case ".":
              if (dt != null) {
                o = c;
                while (++i < fmt2.length && (c = fmt2.charAt(i)) === "0") o += c;
                out[out.length] = { t: "s", v: o };
                break;
              }
            case "0":
            case "#":
              o = c;
              while (++i < fmt2.length && "0#?.,E+-%".indexOf(c = fmt2.charAt(i)) > -1) o += c;
              out[out.length] = { t: "n", v: o };
              break;
            case "?":
              o = c;
              while (fmt2.charAt(++i) === c) o += c;
              out[out.length] = { t: c, v: o };
              lst = c;
              break;
            case "*":
              ++i;
              if (fmt2.charAt(i) == " " || fmt2.charAt(i) == "*") ++i;
              break;
            case "(":
            case ")":
              out[out.length] = { t: flen === 1 ? "t" : c, v: c };
              ++i;
              break;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              o = c;
              while (i < fmt2.length && "0123456789".indexOf(fmt2.charAt(++i)) > -1) o += fmt2.charAt(i);
              out[out.length] = { t: "D", v: o };
              break;
            case " ":
              out[out.length] = { t: c, v: c };
              ++i;
              break;
            case "$":
              out[out.length] = { t: "t", v: "$" };
              ++i;
              break;
            default:
              if (",$-+/():!^&'~{}<>=€acfijklopqrtuvwxzP".indexOf(c) === -1) throw new Error("unrecognized character " + c + " in " + fmt2);
              out[out.length] = { t: "t", v: c };
              ++i;
              break;
          }
        }
        var bt = 0, ss0 = 0, ssm;
        for (i = out.length - 1, lst = "t"; i >= 0; --i) {
          switch (out[i].t) {
            case "h":
            case "H":
              out[i].t = hr;
              lst = "h";
              if (bt < 1) bt = 1;
              break;
            case "s":
              if (ssm = out[i].v.match(/\.0+$/)) ss0 = Math.max(ss0, ssm[0].length - 1);
              if (bt < 3) bt = 3;
            case "d":
            case "y":
            case "M":
            case "e":
              lst = out[i].t;
              break;
            case "m":
              if (lst === "s") {
                out[i].t = "M";
                if (bt < 2) bt = 2;
              }
              break;
            case "X":
              break;
            case "Z":
              if (bt < 1 && out[i].v.match(/[Hh]/)) bt = 1;
              if (bt < 2 && out[i].v.match(/[Mm]/)) bt = 2;
              if (bt < 3 && out[i].v.match(/[Ss]/)) bt = 3;
          }
        }
        switch (bt) {
          case 0:
            break;
          case 1:
            if (dt.u >= 0.5) {
              dt.u = 0;
              ++dt.S;
            }
            if (dt.S >= 60) {
              dt.S = 0;
              ++dt.M;
            }
            if (dt.M >= 60) {
              dt.M = 0;
              ++dt.H;
            }
            break;
          case 2:
            if (dt.u >= 0.5) {
              dt.u = 0;
              ++dt.S;
            }
            if (dt.S >= 60) {
              dt.S = 0;
              ++dt.M;
            }
            break;
        }
        var nstr = "", jj;
        for (i = 0; i < out.length; ++i) {
          switch (out[i].t) {
            case "t":
            case "T":
            case " ":
            case "D":
              break;
            case "X":
              out[i].v = "";
              out[i].t = ";";
              break;
            case "d":
            case "m":
            case "y":
            case "h":
            case "H":
            case "M":
            case "s":
            case "e":
            case "b":
            case "Z":
              out[i].v = write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);
              out[i].t = "t";
              break;
            case "n":
            case "?":
              jj = i + 1;
              while (out[jj] != null && ((c = out[jj].t) === "?" || c === "D" || (c === " " || c === "t") && out[jj + 1] != null && (out[jj + 1].t === "?" || out[jj + 1].t === "t" && out[jj + 1].v === "/") || out[i].t === "(" && (c === " " || c === "n" || c === ")") || c === "t" && (out[jj].v === "/" || out[jj].v === " " && out[jj + 1] != null && out[jj + 1].t == "?"))) {
                out[i].v += out[jj].v;
                out[jj] = { v: "", t: ";" };
                ++jj;
              }
              nstr += out[i].v;
              i = jj - 1;
              break;
            case "G":
              out[i].t = "t";
              out[i].v = general_fmt(v, opts);
              break;
          }
        }
        var vv = "", myv, ostr;
        if (nstr.length > 0) {
          if (nstr.charCodeAt(0) == 40) {
            myv = v < 0 && nstr.charCodeAt(0) === 45 ? -v : v;
            ostr = write_num("n", nstr, myv);
          } else {
            myv = v < 0 && flen > 1 ? -v : v;
            ostr = write_num("n", nstr, myv);
            if (myv < 0 && out[0] && out[0].t == "t") {
              ostr = ostr.substr(1);
              out[0].v = "-" + out[0].v;
            }
          }
          jj = ostr.length - 1;
          var decpt = out.length;
          for (i = 0; i < out.length; ++i) if (out[i] != null && out[i].t != "t" && out[i].v.indexOf(".") > -1) {
            decpt = i;
            break;
          }
          var lasti = out.length;
          if (decpt === out.length && ostr.indexOf("E") === -1) {
            for (i = out.length - 1; i >= 0; --i) {
              if (out[i] == null || "n?".indexOf(out[i].t) === -1) continue;
              if (jj >= out[i].v.length - 1) {
                jj -= out[i].v.length;
                out[i].v = ostr.substr(jj + 1, out[i].v.length);
              } else if (jj < 0) out[i].v = "";
              else {
                out[i].v = ostr.substr(0, jj + 1);
                jj = -1;
              }
              out[i].t = "t";
              lasti = i;
            }
            if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
          } else if (decpt !== out.length && ostr.indexOf("E") === -1) {
            jj = ostr.indexOf(".") - 1;
            for (i = decpt; i >= 0; --i) {
              if (out[i] == null || "n?".indexOf(out[i].t) === -1) continue;
              j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") - 1 : out[i].v.length - 1;
              vv = out[i].v.substr(j + 1);
              for (; j >= 0; --j) {
                if (jj >= 0 && (out[i].v.charAt(j) === "0" || out[i].v.charAt(j) === "#")) vv = ostr.charAt(jj--) + vv;
              }
              out[i].v = vv;
              out[i].t = "t";
              lasti = i;
            }
            if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
            jj = ostr.indexOf(".") + 1;
            for (i = decpt; i < out.length; ++i) {
              if (out[i] == null || "n?(".indexOf(out[i].t) === -1 && i !== decpt) continue;
              j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") + 1 : 0;
              vv = out[i].v.substr(0, j);
              for (; j < out[i].v.length; ++j) {
                if (jj < ostr.length) vv += ostr.charAt(jj++);
              }
              out[i].v = vv;
              out[i].t = "t";
              lasti = i;
            }
          }
        }
        for (i = 0; i < out.length; ++i) if (out[i] != null && "n?".indexOf(out[i].t) > -1) {
          myv = flen > 1 && v < 0 && i > 0 && out[i - 1].v === "-" ? -v : v;
          out[i].v = write_num(out[i].t, out[i].v, myv);
          out[i].t = "t";
        }
        var retval = "";
        for (i = 0; i !== out.length; ++i) if (out[i] != null) retval += out[i].v;
        return retval;
      }
      SSF2._eval = eval_fmt;
      var cfregex = /\[[=<>]/;
      var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
      function chkcond(v, rr) {
        if (rr == null) return false;
        var thresh = parseFloat(rr[2]);
        switch (rr[1]) {
          case "=":
            if (v == thresh) return true;
            break;
          case ">":
            if (v > thresh) return true;
            break;
          case "<":
            if (v < thresh) return true;
            break;
          case "<>":
            if (v != thresh) return true;
            break;
          case ">=":
            if (v >= thresh) return true;
            break;
          case "<=":
            if (v <= thresh) return true;
            break;
        }
        return false;
      }
      function choose_fmt(f, v) {
        var fmt2 = split_fmt(f);
        var l = fmt2.length, lat = fmt2[l - 1].indexOf("@");
        if (l < 4 && lat > -1) --l;
        if (fmt2.length > 4) throw new Error("cannot find right format for |" + fmt2.join("|") + "|");
        if (typeof v !== "number") return [4, fmt2.length === 4 || lat > -1 ? fmt2[fmt2.length - 1] : "@"];
        switch (fmt2.length) {
          case 1:
            fmt2 = lat > -1 ? ["General", "General", "General", fmt2[0]] : [fmt2[0], fmt2[0], fmt2[0], "@"];
            break;
          case 2:
            fmt2 = lat > -1 ? [fmt2[0], fmt2[0], fmt2[0], fmt2[1]] : [fmt2[0], fmt2[1], fmt2[0], "@"];
            break;
          case 3:
            fmt2 = lat > -1 ? [fmt2[0], fmt2[1], fmt2[0], fmt2[2]] : [fmt2[0], fmt2[1], fmt2[2], "@"];
            break;
          case 4:
            break;
        }
        var ff = v > 0 ? fmt2[0] : v < 0 ? fmt2[1] : fmt2[2];
        if (fmt2[0].indexOf("[") === -1 && fmt2[1].indexOf("[") === -1) return [l, ff];
        if (fmt2[0].match(cfregex) != null || fmt2[1].match(cfregex) != null) {
          var m1 = fmt2[0].match(cfregex2);
          var m2 = fmt2[1].match(cfregex2);
          return chkcond(v, m1) ? [l, fmt2[0]] : chkcond(v, m2) ? [l, fmt2[1]] : [l, fmt2[m1 != null && m2 != null ? 2 : 1]];
        }
        return [l, ff];
      }
      function format(fmt2, v, o) {
        if (o == null) o = {};
        var sfmt = "";
        switch (typeof fmt2) {
          case "string":
            if (fmt2 == "m/d/yy" && o.dateNF) sfmt = o.dateNF;
            else sfmt = fmt2;
            break;
          case "number":
            if (fmt2 == 14 && o.dateNF) sfmt = o.dateNF;
            else sfmt = (o.table != null ? o.table : table_fmt)[fmt2];
            if (sfmt == null) sfmt = o.table && o.table[default_map[fmt2]] || table_fmt[default_map[fmt2]];
            if (sfmt == null) sfmt = default_str[fmt2] || "General";
            break;
        }
        if (isgeneral(sfmt, 0)) return general_fmt(v, o);
        if (v instanceof Date) v = datenum_local(v, o.date1904);
        var f = choose_fmt(sfmt, v);
        if (isgeneral(f[1])) return general_fmt(v, o);
        if (v === true) v = "TRUE";
        else if (v === false) v = "FALSE";
        else if (v === "" || v == null) return "";
        return eval_fmt(f[1], v, o, f[0]);
      }
      function load_entry(fmt2, idx) {
        if (typeof idx != "number") {
          idx = +idx || -1;
          for (var i = 0; i < 392; ++i) {
            if (table_fmt[i] == void 0) {
              if (idx < 0) idx = i;
              continue;
            }
            if (table_fmt[i] == fmt2) {
              idx = i;
              break;
            }
          }
          if (idx < 0) idx = 391;
        }
        table_fmt[idx] = fmt2;
        return idx;
      }
      SSF2.load = load_entry;
      SSF2._table = table_fmt;
      SSF2.get_table = function get_table() {
        return table_fmt;
      };
      SSF2.load_table = function load_table(tbl) {
        for (var i = 0; i != 392; ++i)
          if (tbl[i] !== void 0) load_entry(tbl[i], i);
      };
      SSF2.init_table = init_table;
      SSF2.format = format;
    };
    make_ssf(SSF);
    if (typeof module !== "undefined" && typeof DO_NOT_EXPORT_SSF === "undefined") module.exports = SSF;
  }
});

// ../../node_modules/@evidence-dev/component-utilities/src/formatting.js
var import_ssf3 = __toESM(require_ssf());

// ../../node_modules/@evidence-dev/component-utilities/src/autoFormatting.js
var import_ssf = __toESM(require_ssf(), 1);
var AUTO_FORMAT_CODE = "auto";
var AUTO_FORMAT_MEDIAN_PRECISION = 3;
var IMPLICIT_COLUMN_AUTO_FORMATS = [
  {
    name: "year",
    description: 'When lowerCase(columnName)="year" with the column having numeric values will result in no formatting',
    matchingFunction: (columnName, evidenceTypeDescriptor, columnUnitSummary) => {
      if (columnName && evidenceTypeDescriptor) {
        return "year" === columnName.toLowerCase() && ((evidenceTypeDescriptor == null ? void 0 : evidenceTypeDescriptor.evidenceType) === "number" || (columnUnitSummary == null ? void 0 : columnUnitSummary.unitType) === "number");
      }
      return false;
    },
    format: {
      formatCode: AUTO_FORMAT_CODE,
      valueType: "number",
      exampleInput: 2013,
      _autoFormat: {
        autoFormatCode: "@",
        truncateUnits: false
      }
    }
  },
  {
    name: "id",
    description: 'When lowerCase(columnName)="id" with the column having numeric values, then values will have no formatting',
    matchingFunction: (columnName, evidenceTypeDescriptor, columnUnitSummary) => {
      if (columnName && evidenceTypeDescriptor) {
        return "id" === columnName.toLowerCase() && ((evidenceTypeDescriptor == null ? void 0 : evidenceTypeDescriptor.evidenceType) === "number" || (columnUnitSummary == null ? void 0 : columnUnitSummary.unitType) === "number");
      }
      return false;
    },
    format: {
      formatCode: AUTO_FORMAT_CODE,
      valueType: "number",
      exampleInput: 93120121,
      _autoFormat: {
        autoFormatFunction: (typedValue) => {
          if (typedValue !== null && typedValue !== void 0 && !isNaN(typedValue)) {
            return typedValue.toLocaleString("fullwide", {
              useGrouping: false
            });
          } else {
            return typedValue;
          }
        }
      }
    }
  },
  {
    name: "defaultDate",
    description: "Formatting for Default Date",
    matchingFunction: (columnName, evidenceTypeDescriptor, columnUnitSummary) => {
      if (evidenceTypeDescriptor) {
        return (evidenceTypeDescriptor == null ? void 0 : evidenceTypeDescriptor.evidenceType) === "date" || (columnUnitSummary == null ? void 0 : columnUnitSummary.unitType) === "date";
      }
      return false;
    },
    format: {
      formatCode: AUTO_FORMAT_CODE,
      valueType: "date",
      exampleInput: "Sat Jan 01 2022 03:15:00 GMT-0500",
      _autoFormat: {
        autoFormatCode: "YYYY-MM-DD",
        truncateUnits: false
      }
    }
  }
];
var applyColumnUnits = (value, unit) => {
  switch (unit) {
    case "T":
      return value / 1e12;
    case "B":
      return value / 1e9;
    case "M":
      return value / 1e6;
    case "k":
      return value / 1e3;
    default:
      return value;
  }
};
var isAutoFormat = (format, effectiveCode) => {
  var _a, _b, _c;
  let matchesCode = ((_a = effectiveCode || format.formatCode) == null ? void 0 : _a.toLowerCase()) === AUTO_FORMAT_CODE;
  let autoFormatCode = ((_b = format._autoFormat) == null ? void 0 : _b.autoFormatFunction) || ((_c = format._autoFormat) == null ? void 0 : _c.autoFormatCode);
  if (matchesCode && autoFormatCode !== void 0) {
    return true;
  } else {
    return false;
  }
};
var generateImplicitNumberFormat = (columnUnitSummary, maxDisplayDecimals = 7) => {
  let effectiveFormatCode;
  let columnUnits = "";
  let median2 = columnUnitSummary == null ? void 0 : columnUnitSummary.median;
  let truncateUnits;
  if (median2 !== void 0) {
    let medianInUnitTerms;
    columnUnits = getAutoColumnUnit(median2);
    if (columnUnits) {
      medianInUnitTerms = applyColumnUnits(median2, columnUnits);
      truncateUnits = true;
    } else {
      medianInUnitTerms = median2;
      truncateUnits = false;
    }
    if (columnUnitSummary.maxDecimals === 0 && !truncateUnits) {
      effectiveFormatCode = "#,##0";
    } else {
      effectiveFormatCode = computeNumberAutoFormatCode(medianInUnitTerms, maxDisplayDecimals);
    }
  } else {
    effectiveFormatCode = "#,##0";
    truncateUnits = false;
  }
  return {
    formatCode: AUTO_FORMAT_CODE,
    valueType: "number",
    _autoFormat: {
      autoFormatCode: effectiveFormatCode,
      truncateUnits,
      columnUnits
    }
  };
};
var findImplicitAutoFormat = (columnName, evidenceTypeDescriptor, columnUnitSummary) => {
  let matched = IMPLICIT_COLUMN_AUTO_FORMATS.find(
    (implicitFormat) => implicitFormat.matchingFunction(columnName, evidenceTypeDescriptor, columnUnitSummary)
  );
  if (matched) {
    return matched.format;
  } else {
    if ((columnUnitSummary == null ? void 0 : columnUnitSummary.unitType) === "number") {
      return generateImplicitNumberFormat(columnUnitSummary);
    }
  }
  return void 0;
};
var autoFormat = (typedValue, columnFormat, columnUnitSummary = void 0) => {
  var _a, _b, _c;
  if ((_a = columnFormat._autoFormat) == null ? void 0 : _a.autoFormatFunction) {
    return columnFormat._autoFormat.autoFormatFunction(typedValue, columnFormat, columnUnitSummary);
  } else if (columnFormat._autoFormat.autoFormatCode) {
    let autoFormatCode = (_b = columnFormat == null ? void 0 : columnFormat._autoFormat) == null ? void 0 : _b.autoFormatCode;
    let valueType = columnFormat.valueType;
    if ("number" === valueType) {
      let truncateUnits = (_c = columnFormat == null ? void 0 : columnFormat._autoFormat) == null ? void 0 : _c.truncateUnits;
      let unitValue = typedValue;
      let unit = "";
      if (truncateUnits && (columnUnitSummary == null ? void 0 : columnUnitSummary.median) !== void 0) {
        unit = getAutoColumnUnit(columnUnitSummary.median);
        unitValue = applyColumnUnits(typedValue, unit);
      }
      return import_ssf.default.format(autoFormatCode, unitValue) + unit;
    } else {
      return import_ssf.default.format(autoFormatCode, typedValue);
    }
  } else {
    console.warn("autoFormat called without a formatCode or function");
  }
  return typedValue;
};
var fallbackFormat = (typedValue) => {
  if (typeof typedValue === "number") {
    return typedValue.toLocaleString(void 0, {
      minimumFractionDigits: 0,
      maximumFractionDigits: 2
    });
  } else if (typedValue !== void 0 && typedValue !== null) {
    return typedValue == null ? void 0 : typedValue.toString();
  } else {
    return "-";
  }
};
function computeNumberAutoFormatCode(referenceValue, maxDisplayDecimals = 7, significantDigits = AUTO_FORMAT_MEDIAN_PRECISION) {
  let formatCodeBuilder = "#,##0";
  let referenceValueLeadingDigitExponent = base10Exponent(referenceValue);
  let displayDecimals = 0;
  if (referenceValueLeadingDigitExponent - significantDigits < 0) {
    displayDecimals = Math.min(
      Math.max(Math.abs(referenceValueLeadingDigitExponent - significantDigits + 1), 0),
      maxDisplayDecimals
    );
  }
  if (displayDecimals > 0) {
    formatCodeBuilder += ".";
    formatCodeBuilder += "0".repeat(displayDecimals);
  }
  return formatCodeBuilder;
}
function getAutoColumnUnit(value) {
  let absoluteValue = Math.abs(value);
  if (absoluteValue >= 5e12) {
    return "T";
  } else if (absoluteValue >= 5e9) {
    return "B";
  } else if (absoluteValue >= 5e6) {
    return "M";
  } else if (absoluteValue >= 5e3) {
    return "k";
  } else {
    return "";
  }
}
function base10Exponent(value) {
  if (value === 0) {
    return 0;
  } else {
    return Math.floor(Math.log10(value));
  }
}

// ../../node_modules/@evidence-dev/component-utilities/src/builtInFormats.js
var import_ssf2 = __toESM(require_ssf(), 1);
var SUPPORTED_CURRENCIES = [
  {
    primaryCode: "usd",
    currencySymbol: "$",
    displayName: "USD - United States Dollar"
  },
  {
    primaryCode: "aud",
    currencySymbol: "A$",
    displayName: "AUD - Australian Dollar",
    escapeCurrencySymbol: true
  },
  {
    primaryCode: "brl",
    currencySymbol: "R$",
    displayName: "BRL - Brazilian Real",
    escapeCurrencySymbol: true
  },
  {
    primaryCode: "cad",
    currencySymbol: "C$",
    displayName: "CAD - Canadian Dollar",
    escapeCurrencySymbol: true
  },
  {
    primaryCode: "cny",
    currencySymbol: "¥",
    displayName: "CNY - Renminbi",
    escapeCurrencySymbol: true
  },
  { primaryCode: "eur", currencySymbol: "€", displayName: "EUR - Euro" },
  {
    primaryCode: "gbp",
    currencySymbol: "£",
    displayName: "GBP - Pound Sterling",
    escapeCurrencySymbol: true
  },
  {
    primaryCode: "jpy",
    currencySymbol: "¥",
    displayName: "JPY - Japanese Yen",
    escapeCurrencySymbol: true
  },
  {
    primaryCode: "inr",
    currencySymbol: "₹",
    displayName: "INR - Indian Rupee",
    escapeCurrencySymbol: true
  },
  {
    primaryCode: "krw",
    currencySymbol: "₩",
    displayName: "KRW - South Korean won",
    escapeCurrencySymbol: true
  },
  {
    primaryCode: "ngn",
    currencySymbol: "₦",
    displayName: "NGN -  Nigerian Naira",
    escapeCurrencySymbol: true
  },
  {
    primaryCode: "rub",
    currencySymbol: "rub",
    displayName: "RUB - Russian Ruble",
    escapeCurrencySymbol: true
  },
  {
    primaryCode: "sek",
    currencySymbol: "kr",
    displayName: "SEK - Swedish Krona",
    escapeCurrencySymbol: true
  }
];
var DERIVED_CURRENCY_FORMATS = [
  {
    derivedSuffix: "",
    valueFormatCode: "#,##0",
    exampleInput: 412.17,
    auto: true
  },
  {
    derivedSuffix: "0",
    valueFormatCode: "#,##0",
    exampleInput: 7043.123
  },
  {
    derivedSuffix: "1",
    valueFormatCode: "#,##0.0",
    exampleInput: 7043.123
  },
  {
    derivedSuffix: "2",
    valueFormatCode: "#,##0.00",
    exampleInput: 7043.123
  },
  {
    derivedSuffix: "0k",
    valueFormatCode: '#,##0,"k"',
    exampleInput: 64301.12
  },
  {
    derivedSuffix: "1k",
    valueFormatCode: '#,##0.0,"k"',
    exampleInput: 64301.12
  },
  {
    derivedSuffix: "2k",
    valueFormatCode: '#,##0.00,"k"',
    exampleInput: 64301.12
  },
  {
    derivedSuffix: "0m",
    valueFormatCode: '#,##0,,"M"',
    exampleInput: 456430112e-2
  },
  {
    derivedSuffix: "1m",
    valueFormatCode: '#,##0.0,,"M"',
    exampleInput: 456430112e-2
  },
  {
    derivedSuffix: "2m",
    valueFormatCode: '#,##0.00,,"M"',
    exampleInput: 456430112e-2
  },
  {
    derivedSuffix: "0b",
    valueFormatCode: '#,##0,,,"B"',
    exampleInput: 978456430112e-2
  },
  {
    derivedSuffix: "1b",
    valueFormatCode: '#,##0.0,,,"B"',
    exampleInput: 978456430112e-2
  },
  {
    derivedSuffix: "2b",
    valueFormatCode: '#,##0.00,,,"B"',
    exampleInput: 978456430112e-2
  }
];
var CURRENCY_FORMATS = SUPPORTED_CURRENCIES.map((currency) => {
  let derivedFormats = [];
  DERIVED_CURRENCY_FORMATS.forEach((derivedFormat) => {
    let next = {
      formatTag: currency.primaryCode + derivedFormat.derivedSuffix,
      parentFormat: currency.primaryCode,
      formatCategory: "currency",
      valueType: "number",
      exampleInput: derivedFormat.exampleInput,
      titleTagReplacement: ` (${currency.currencySymbol})`
    };
    let symbolInFormatCode = currency.escapeCurrencySymbol ? `"${currency.currencySymbol}"` : currency.currencySymbol;
    if (derivedFormat.auto || AUTO_FORMAT_CODE === derivedFormat.formatCode) {
      next.formatCode = AUTO_FORMAT_CODE;
      next._autoFormat = {
        autoFormatFunction: (typedValue, columnFormat, columnUnitSummary) => {
          let format = generateImplicitNumberFormat(columnUnitSummary, 2);
          let effectiveCode = `${symbolInFormatCode}${format._autoFormat.autoFormatCode}`;
          let suffix = "";
          let displayValue = typedValue;
          if (format._autoFormat.truncateUnits && format._autoFormat.columnUnits) {
            suffix = format._autoFormat.columnUnits;
            displayValue = applyColumnUnits(typedValue, format._autoFormat.columnUnits);
          } else {
            if (effectiveCode.endsWith(".0")) {
              effectiveCode = effectiveCode + "0";
            }
          }
          return import_ssf2.default.format(effectiveCode, displayValue) + suffix;
        }
      };
    } else {
      next.formatCode = `${symbolInFormatCode}${derivedFormat.valueFormatCode}`;
    }
    if (derivedFormat.axisValueFormatCode) {
      next.axisFormatCode = derivedFormat.axisValueFormatCode;
    }
    derivedFormats.push(next);
  });
  return derivedFormats;
}).flat();
var BUILT_IN_FORMATS = [
  ...CURRENCY_FORMATS,
  //auto formats
  // Date/Time:
  {
    formatTag: "ddd",
    formatCode: "ddd",
    formatCategory: "date",
    valueType: "date",
    exampleInput: "2022-01-09 12:45"
  },
  {
    formatTag: "dddd",
    formatCode: "dddd",
    formatCategory: "date",
    valueType: "date",
    exampleInput: "2022-01-09 12:45"
  },
  {
    formatTag: "mmm",
    formatCode: "mmm",
    formatCategory: "date",
    valueType: "date",
    exampleInput: "2022-01-09 12:45"
  },
  {
    formatTag: "mmmm",
    formatCode: "mmmm",
    formatCategory: "date",
    valueType: "date",
    exampleInput: "2022-01-09 12:45"
  },
  {
    formatTag: "yyyy",
    formatCode: "yyyy",
    formatCategory: "date",
    valueType: "date",
    exampleInput: "2022-01-09 12:45"
  },
  {
    formatTag: "shortdate",
    formatCode: "mmm d/yy",
    formatCategory: "date",
    valueType: "date",
    exampleInput: "2022-01-09 12:45"
  },
  {
    formatTag: "longdate",
    formatCode: "mmmm d, yyyy",
    formatCategory: "date",
    valueType: "date",
    exampleInput: "2022-01-09 12:45"
  },
  {
    formatTag: "fulldate",
    formatCode: "dddd mmmm d, yyyy",
    formatCategory: "date",
    valueType: "date",
    exampleInput: "2022-01-09 12:45"
  },
  {
    formatTag: "mdy",
    formatCode: "m/d/y",
    formatCategory: "date",
    valueType: "date",
    exampleInput: "2022-01-09 12:45"
  },
  {
    formatTag: "dmy",
    formatCode: "d/m/y",
    formatCategory: "date",
    valueType: "date",
    exampleInput: "2022-01-09 12:45"
  },
  {
    formatTag: "hms",
    formatCode: "H:MM:SS AM/PM",
    formatCategory: "date",
    valueType: "date",
    exampleInput: "2022-01-09T11:45:03"
  },
  // Numbers:
  {
    formatTag: "num0",
    formatCode: "#,##0",
    formatCategory: "number",
    valueType: "number",
    exampleInput: 11.23168
  },
  {
    formatTag: "num1",
    formatCode: "#,##0.0",
    formatCategory: "number",
    valueType: "number",
    exampleInput: 11.23168
  },
  {
    formatTag: "num2",
    formatCode: "#,##0.00",
    formatCategory: "number",
    valueType: "number",
    exampleInput: 11.23168
  },
  {
    formatTag: "num3",
    formatCode: "#,##0.000",
    formatCategory: "number",
    valueType: "number",
    exampleInput: 11.23168
  },
  {
    formatTag: "num4",
    formatCode: "#,##0.0000",
    formatCategory: "number",
    valueType: "number",
    exampleInput: 11.23168
  },
  {
    formatTag: "num0k",
    formatCode: '#,##0,"k"',
    formatCategory: "number",
    valueType: "number",
    exampleInput: 64201
  },
  {
    formatTag: "num1k",
    formatCode: '#,##0.0,"k"',
    formatCategory: "number",
    valueType: "number",
    exampleInput: 64201
  },
  {
    formatTag: "num2k",
    formatCode: '#,##0.00,"k"',
    formatCategory: "number",
    valueType: "number",
    exampleInput: 64201
  },
  {
    formatTag: "num0m",
    formatCode: '#,##0,,"M"',
    formatCategory: "number",
    valueType: "number",
    exampleInput: 42539483
  },
  {
    formatTag: "num1m",
    formatCode: '#,##0.0,,"M"',
    formatCategory: "number",
    valueType: "number",
    exampleInput: 42539483
  },
  {
    formatTag: "num2m",
    formatCode: '#,##0.00,,"M"',
    formatCategory: "number",
    valueType: "number",
    exampleInput: 42539483
  },
  {
    formatTag: "num0b",
    formatCode: '#,##0,,,"B"',
    formatCategory: "number",
    valueType: "number",
    exampleInput: 1384937584
  },
  {
    formatTag: "num1b",
    formatCode: '#,##0.0,,,"B"',
    formatCategory: "number",
    valueType: "number",
    exampleInput: 1384937584
  },
  {
    formatTag: "num2b",
    formatCode: '#,##0.00,,,"B"',
    formatCategory: "number",
    valueType: "number",
    exampleInput: 1384937584
  },
  {
    formatTag: "id",
    formatCode: "0",
    formatCategory: "number",
    valueType: "number",
    exampleInput: "921594675",
    titleTagReplacement: " id"
  },
  {
    formatTag: "fract",
    formatCode: "# ?/?",
    formatCategory: "number",
    valueType: "number",
    exampleInput: "0.25"
  },
  {
    formatTag: "mult",
    formatCode: '#,##0.0"x"',
    formatCategory: "number",
    valueType: "number",
    exampleInput: "5.32"
  },
  {
    formatTag: "mult0",
    formatCode: '#,##0"x"',
    formatCategory: "number",
    valueType: "number",
    exampleInput: "5.32"
  },
  {
    formatTag: "mult1",
    formatCode: '#,##0.0"x"',
    formatCategory: "number",
    valueType: "number",
    exampleInput: "5.32"
  },
  {
    formatTag: "mult2",
    formatCode: '#,##0.00"x"',
    formatCategory: "number",
    valueType: "number",
    exampleInput: "5.32"
  },
  {
    formatTag: "sci",
    formatCode: "0.00E+0",
    formatCategory: "number",
    valueType: "number",
    exampleInput: "16546.1561"
  },
  // Percent:
  {
    formatTag: "pct",
    formatCode: AUTO_FORMAT_CODE,
    formatCategory: "percent",
    valueType: "number",
    exampleInput: 0.731,
    titleTagReplacement: "",
    _autoFormat: {
      autoFormatFunction: (typedValue, columnFormat, columnUnitSummary) => {
        if ("number" === (columnUnitSummary == null ? void 0 : columnUnitSummary.unitType)) {
          let adjustedColumnUnitSummary = {
            min: columnUnitSummary.min * 100,
            max: columnUnitSummary.max * 100,
            median: columnUnitSummary.median * 100,
            maxDecimals: Math.max(columnUnitSummary.maxDecimals - 2, 0),
            unitType: columnUnitSummary.unitType
          };
          let format = generateImplicitNumberFormat(adjustedColumnUnitSummary);
          return import_ssf2.default.format(format._autoFormat.autoFormatCode, typedValue * 100) + "%";
        } else {
          return import_ssf2.default.format("#,##0%", typedValue);
        }
      }
    }
  },
  {
    formatTag: "pct0",
    formatCode: "#,##0%",
    formatCategory: "percent",
    valueType: "number",
    exampleInput: 0.731,
    titleTagReplacement: ""
  },
  {
    formatTag: "pct1",
    formatCode: "#,##0.0%",
    formatCategory: "percent",
    valueType: "number",
    exampleInput: 0.731,
    titleTagReplacement: ""
  },
  {
    formatTag: "pct2",
    formatCode: "#,##0.00%",
    formatCategory: "percent",
    valueType: "number",
    exampleInput: 0.731,
    titleTagReplacement: ""
  },
  {
    formatTag: "pct3",
    formatCode: "#,##0.000%",
    formatCategory: "percent",
    valueType: "number",
    exampleInput: 0.731,
    titleTagReplacement: ""
  }
];

// ../../node_modules/@tidyjs/tidy/dist/es/tidy.js
function tidy(items, ...fns) {
  if (typeof items === "function") {
    throw new Error("You must supply the data as the first argument to tidy()");
  }
  let result = items;
  for (const fn of fns) {
    if (fn) {
      result = fn(result);
    }
  }
  return result;
}

// ../../node_modules/@tidyjs/tidy/dist/es/helpers/singleOrArray.js
function singleOrArray(d) {
  return d == null ? [] : Array.isArray(d) ? d : [d];
}

// ../../node_modules/d3-array/src/ascending.js
function ascending_default(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// ../../node_modules/d3-array/src/bisector.js
function bisector_default(f) {
  let delta = f;
  let compare = f;
  if (f.length === 1) {
    delta = (d, x) => f(d) - x;
    compare = ascendingComparator(f);
  }
  function left(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) < 0) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }
  function right(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) > 0) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }
  function center(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return { left, center, right };
}
function ascendingComparator(f) {
  return (d, x) => ascending_default(f(d), x);
}

// ../../node_modules/d3-array/src/number.js
function number_default(x) {
  return x === null ? NaN : +x;
}
function* numbers(values, valueof) {
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

// ../../node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector_default(number_default).center;

// ../../node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j], hi = x + y, lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n2 = this._n, x, y, lo, hi = 0;
    if (n2 > 0) {
      hi = p[--n2];
      while (n2 > 0) {
        x = hi;
        y = p[--n2];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }
      if (n2 > 0 && (lo < 0 && p[n2 - 1] < 0 || lo > 0 && p[n2 - 1] > 0)) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }
    return hi;
  }
};
function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === void 0) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index2, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}

// ../../node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(value);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// ../../node_modules/d3-array/src/identity.js
function identity_default(x) {
  return x;
}

// ../../node_modules/d3-array/src/group.js
function group(values, ...keys) {
  return nest(values, identity_default, identity_default, keys);
}
function nest(values, map4, reduce2, keys) {
  return function regroup(values2, i) {
    if (i >= keys.length) return reduce2(values2);
    const groups2 = new InternMap();
    const keyof2 = keys[i++];
    let index2 = -1;
    for (const value of values2) {
      const key = keyof2(value, ++index2, values2);
      const group2 = groups2.get(key);
      if (group2) group2.push(value);
      else groups2.set(key, [value]);
    }
    for (const [key, values3] of groups2) {
      groups2.set(key, regroup(values3, i));
    }
    return map4(groups2);
  }(values, 0);
}

// ../../node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// ../../node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

// ../../node_modules/d3-array/src/max.js
function max(values, valueof) {
  let max3;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  }
  return max3;
}

// ../../node_modules/d3-array/src/min.js
function min(values, valueof) {
  let min3;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (min3 > value || min3 === void 0 && value >= value)) {
        min3 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (min3 > value || min3 === void 0 && value >= value)) {
        min3 = value;
      }
    }
  }
  return min3;
}

// ../../node_modules/d3-array/src/quickselect.js
function quickselect(array2, k, left = 0, right = array2.length - 1, compare = ascending_default) {
  while (right > left) {
    if (right - left > 600) {
      const n2 = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n2);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n2 - s) / n2) * (m - n2 / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n2 + sd));
      const newRight = Math.min(right, Math.floor(k + (n2 - m) * s / n2 + sd));
      quickselect(array2, k, newLeft, newRight, compare);
    }
    const t = array2[k];
    let i = left;
    let j = right;
    swap(array2, left, k);
    if (compare(array2[right], t) > 0) swap(array2, left, right);
    while (i < j) {
      swap(array2, i, j), ++i, --j;
      while (compare(array2[i], t) < 0) ++i;
      while (compare(array2[j], t) > 0) --j;
    }
    if (compare(array2[left], t) === 0) swap(array2, left, j);
    else ++j, swap(array2, j, right);
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
  return array2;
}
function swap(array2, i, j) {
  const t = array2[i];
  array2[i] = array2[j];
  array2[j] = t;
}

// ../../node_modules/d3-array/src/quantile.js
function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n2 = values.length)) return;
  if ((p = +p) <= 0 || n2 < 2) return min(values);
  if (p >= 1) return max(values);
  var n2, i = (n2 - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

// ../../node_modules/d3-array/src/median.js
function median_default(values, valueof) {
  return quantile(values, 0.5, valueof);
}

// ../../node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle(array2, i0 = 0, i1 = array2.length) {
    let m = i1 - (i0 = +i0);
    while (m) {
      const i = random() * m-- | 0, t = array2[m + i0];
      array2[m + i0] = array2[i + i0];
      array2[i + i0] = t;
    }
    return array2;
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/summarize.js
function summarize(summarizeSpec, options) {
  const _summarize = (items) => {
    options = options != null ? options : {};
    const summarized = {};
    const keys = Object.keys(summarizeSpec);
    for (const key of keys) {
      summarized[key] = summarizeSpec[key](items);
    }
    if (options.rest && items.length) {
      const objectKeys = Object.keys(items[0]);
      for (const objKey of objectKeys) {
        if (keys.includes(objKey)) {
          continue;
        }
        summarized[objKey] = options.rest(objKey)(items);
      }
    }
    return [summarized];
  };
  return _summarize;
}
function _summarizeHelper(items, summaryFn, predicateFn, keys) {
  if (!items.length)
    return [];
  const summarized = {};
  let keysArr;
  if (keys == null) {
    keysArr = Object.keys(items[0]);
  } else {
    keysArr = [];
    for (const keyInput of singleOrArray(keys)) {
      if (typeof keyInput === "function") {
        keysArr.push(...keyInput(items));
      } else {
        keysArr.push(keyInput);
      }
    }
  }
  for (const key of keysArr) {
    if (predicateFn) {
      const vector = items.map((d) => d[key]);
      if (!predicateFn(vector)) {
        continue;
      }
    }
    summarized[key] = summaryFn(key)(items);
  }
  return [summarized];
}
function summarizeAt(keys, summaryFn) {
  const _summarizeAt = (items) => _summarizeHelper(items, summaryFn, void 0, keys);
  return _summarizeAt;
}

// ../../node_modules/@tidyjs/tidy/dist/es/mutate.js
function mutate(mutateSpec) {
  const _mutate = (items) => {
    const mutatedItems = items.map((d) => ({ ...d }));
    let i = 0;
    for (const mutatedItem of mutatedItems) {
      for (const key in mutateSpec) {
        const mutateSpecValue = mutateSpec[key];
        const mutatedResult = typeof mutateSpecValue === "function" ? mutateSpecValue(mutatedItem, i, mutatedItems) : mutateSpecValue;
        mutatedItem[key] = mutatedResult;
      }
      ++i;
    }
    return mutatedItems;
  };
  return _mutate;
}

// ../../node_modules/@tidyjs/tidy/dist/es/helpers/assignGroupKeys.js
function assignGroupKeys(d, keys) {
  if (d == null || typeof d !== "object" || Array.isArray(d))
    return d;
  const keysObj = Object.fromEntries(keys.filter((key) => typeof key[0] !== "function" && key[0] != null));
  return Object.assign(keysObj, d);
}

// ../../node_modules/@tidyjs/tidy/dist/es/helpers/groupTraversal.js
function groupTraversal(grouped, outputGrouped, keys, addSubgroup, addLeaves, level = 0) {
  for (const [key, value] of grouped.entries()) {
    const keysHere = [...keys, key];
    if (value instanceof Map) {
      const subgroup = addSubgroup(outputGrouped, keysHere, level);
      groupTraversal(value, subgroup, keysHere, addSubgroup, addLeaves, level + 1);
    } else {
      addLeaves(outputGrouped, keysHere, value, level);
    }
  }
  return outputGrouped;
}

// ../../node_modules/@tidyjs/tidy/dist/es/helpers/groupMap.js
function groupMap(grouped, groupFn, keyFn = (keys) => keys[keys.length - 1]) {
  function addSubgroup(parentGrouped, keys) {
    const subgroup = /* @__PURE__ */ new Map();
    parentGrouped.set(keyFn(keys), subgroup);
    return subgroup;
  }
  function addLeaves(parentGrouped, keys, values) {
    parentGrouped.set(keyFn(keys), groupFn(values, keys));
  }
  const outputGrouped = /* @__PURE__ */ new Map();
  groupTraversal(grouped, outputGrouped, [], addSubgroup, addLeaves);
  return outputGrouped;
}

// ../../node_modules/@tidyjs/tidy/dist/es/helpers/identity.js
var identity = (d) => d;

// ../../node_modules/@tidyjs/tidy/dist/es/helpers/isObject.js
function isObject(obj) {
  const type = typeof obj;
  return obj != null && (type === "object" || type === "function");
}

// ../../node_modules/@tidyjs/tidy/dist/es/groupBy.js
function groupBy(groupKeys, fns, options) {
  if (typeof fns === "function") {
    fns = [fns];
  } else if (arguments.length === 2 && fns != null && !Array.isArray(fns)) {
    options = fns;
  }
  const _groupBy = (items) => {
    const grouped = makeGrouped(items, groupKeys);
    const results = runFlow(grouped, fns, options == null ? void 0 : options.addGroupKeys);
    if (options == null ? void 0 : options.export) {
      switch (options.export) {
        case "grouped":
          return results;
        case "levels":
          return exportLevels(results, options);
        case "entries-obj":
        case "entriesObject":
          return exportLevels(results, {
            ...options,
            export: "levels",
            levels: ["entries-object"]
          });
        default:
          return exportLevels(results, {
            ...options,
            export: "levels",
            levels: [options.export]
          });
      }
    }
    const ungrouped = ungroup(results, options == null ? void 0 : options.addGroupKeys);
    return ungrouped;
  };
  return _groupBy;
}
groupBy.grouped = (options) => ({ ...options, export: "grouped" });
groupBy.entries = (options) => ({ ...options, export: "entries" });
groupBy.entriesObject = (options) => ({ ...options, export: "entries-object" });
groupBy.object = (options) => ({ ...options, export: "object" });
groupBy.map = (options) => ({ ...options, export: "map" });
groupBy.keys = (options) => ({ ...options, export: "keys" });
groupBy.values = (options) => ({ ...options, export: "values" });
groupBy.levels = (options) => ({ ...options, export: "levels" });
function runFlow(items, fns, addGroupKeys) {
  let result = items;
  if (!(fns == null ? void 0 : fns.length))
    return result;
  for (const fn of fns) {
    if (!fn)
      continue;
    result = groupMap(result, (items2, keys) => {
      const context = { groupKeys: keys };
      let leafItemsMapped = fn(items2, context);
      if (addGroupKeys !== false) {
        leafItemsMapped = leafItemsMapped.map((item) => assignGroupKeys(item, keys));
      }
      return leafItemsMapped;
    });
  }
  return result;
}
function makeGrouped(items, groupKeys) {
  const groupKeyFns = singleOrArray(groupKeys).map((key, i) => {
    const keyFn = typeof key === "function" ? key : (d) => d[key];
    const keyCache = /* @__PURE__ */ new Map();
    return (d) => {
      const keyValue = keyFn(d);
      const keyValueOf = isObject(keyValue) ? keyValue.valueOf() : keyValue;
      if (keyCache.has(keyValueOf)) {
        return keyCache.get(keyValueOf);
      }
      const keyWithName = [key, keyValue];
      keyCache.set(keyValueOf, keyWithName);
      return keyWithName;
    };
  });
  const grouped = group(items, ...groupKeyFns);
  return grouped;
}
function ungroup(grouped, addGroupKeys) {
  const items = [];
  groupTraversal(grouped, items, [], identity, (root, keys, values) => {
    let valuesToAdd = values;
    if (addGroupKeys !== false) {
      valuesToAdd = values.map((d) => assignGroupKeys(d, keys));
    }
    root.push(...valuesToAdd);
  });
  return items;
}
var defaultCompositeKey = (keys) => keys.join("/");
function processFromGroupsOptions(options) {
  var _a;
  const {
    flat,
    single,
    mapLeaf = identity,
    mapLeaves = identity,
    addGroupKeys
  } = options;
  let compositeKey;
  if (options.flat) {
    compositeKey = (_a = options.compositeKey) != null ? _a : defaultCompositeKey;
  }
  const groupFn = (values, keys) => {
    return single ? mapLeaf(addGroupKeys === false ? values[0] : assignGroupKeys(values[0], keys)) : mapLeaves(values.map((d) => mapLeaf(addGroupKeys === false ? d : assignGroupKeys(d, keys))));
  };
  const keyFn = flat ? (keys) => compositeKey(keys.map((d) => d[1])) : (keys) => keys[keys.length - 1][1];
  return { groupFn, keyFn };
}
function exportLevels(grouped, options) {
  const { groupFn, keyFn } = processFromGroupsOptions(options);
  let { mapEntry = identity } = options;
  const { levels = ["entries"] } = options;
  const levelSpecs = [];
  for (const levelOption of levels) {
    switch (levelOption) {
      case "entries":
      case "entries-object":
      case "entries-obj":
      case "entriesObject": {
        const levelMapEntry = (levelOption === "entries-object" || levelOption === "entries-obj" || levelOption === "entriesObject") && options.mapEntry == null ? ([key, values]) => ({ key, values }) : mapEntry;
        levelSpecs.push({
          id: "entries",
          createEmptySubgroup: () => [],
          addSubgroup: (parentGrouped, newSubgroup, key, level) => {
            parentGrouped.push(levelMapEntry([key, newSubgroup], level));
          },
          addLeaf: (parentGrouped, key, values, level) => {
            parentGrouped.push(levelMapEntry([key, values], level));
          }
        });
        break;
      }
      case "map":
        levelSpecs.push({
          id: "map",
          createEmptySubgroup: () => /* @__PURE__ */ new Map(),
          addSubgroup: (parentGrouped, newSubgroup, key) => {
            parentGrouped.set(key, newSubgroup);
          },
          addLeaf: (parentGrouped, key, values) => {
            parentGrouped.set(key, values);
          }
        });
        break;
      case "object":
        levelSpecs.push({
          id: "object",
          createEmptySubgroup: () => ({}),
          addSubgroup: (parentGrouped, newSubgroup, key) => {
            parentGrouped[key] = newSubgroup;
          },
          addLeaf: (parentGrouped, key, values) => {
            parentGrouped[key] = values;
          }
        });
        break;
      case "keys":
        levelSpecs.push({
          id: "keys",
          createEmptySubgroup: () => [],
          addSubgroup: (parentGrouped, newSubgroup, key) => {
            parentGrouped.push([key, newSubgroup]);
          },
          addLeaf: (parentGrouped, key) => {
            parentGrouped.push(key);
          }
        });
        break;
      case "values":
        levelSpecs.push({
          id: "values",
          createEmptySubgroup: () => [],
          addSubgroup: (parentGrouped, newSubgroup) => {
            parentGrouped.push(newSubgroup);
          },
          addLeaf: (parentGrouped, key, values) => {
            parentGrouped.push(values);
          }
        });
        break;
      default: {
        if (typeof levelOption === "object") {
          levelSpecs.push(levelOption);
        }
      }
    }
  }
  const addSubgroup = (parentGrouped, keys, level) => {
    var _a, _b;
    if (options.flat) {
      return parentGrouped;
    }
    const levelSpec = (_a = levelSpecs[level]) != null ? _a : levelSpecs[levelSpecs.length - 1];
    const nextLevelSpec = (_b = levelSpecs[level + 1]) != null ? _b : levelSpec;
    const newSubgroup = nextLevelSpec.createEmptySubgroup();
    levelSpec.addSubgroup(parentGrouped, newSubgroup, keyFn(keys), level);
    return newSubgroup;
  };
  const addLeaf = (parentGrouped, keys, values, level) => {
    var _a;
    const levelSpec = (_a = levelSpecs[level]) != null ? _a : levelSpecs[levelSpecs.length - 1];
    levelSpec.addLeaf(parentGrouped, keyFn(keys), groupFn(values, keys), level);
  };
  const initialOutputObject = levelSpecs[0].createEmptySubgroup();
  return groupTraversal(grouped, initialOutputObject, [], addSubgroup, addLeaf);
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/n.js
function n(options) {
  if (options == null ? void 0 : options.predicate) {
    const predicate = options.predicate;
    return (items) => items.reduce((n2, d, i) => predicate(d, i, items) ? n2 + 1 : n2, 0);
  }
  return (items) => items.length;
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/sum.js
function sum2(key, options) {
  let keyFn = typeof key === "function" ? key : (d) => d[key];
  if (options == null ? void 0 : options.predicate) {
    const originalKeyFn = keyFn;
    const predicate = options.predicate;
    keyFn = (d, index2, array2) => predicate(d, index2, array2) ? originalKeyFn(d, index2, array2) : 0;
  }
  return (items) => fsum(items, keyFn);
}

// ../../node_modules/@tidyjs/tidy/dist/es/rename.js
function rename(renameSpec) {
  const _rename = (items) => {
    return items.map((d) => {
      var _a;
      const mapped = {};
      const keys = Object.keys(d);
      for (const key of keys) {
        const newKey = (_a = renameSpec[key]) != null ? _a : key;
        mapped[newKey] = d[key];
      }
      return mapped;
    });
  };
  return _rename;
}

// ../../node_modules/@tidyjs/tidy/dist/es/innerJoin.js
function autodetectByMap(itemsA, itemsB) {
  if (itemsA.length === 0 || itemsB.length === 0)
    return {};
  const keysA = Object.keys(itemsA[0]);
  const keysB = Object.keys(itemsB[0]);
  const byMap = {};
  for (const key of keysA) {
    if (keysB.includes(key)) {
      byMap[key] = key;
    }
  }
  return byMap;
}
function makeByMap(by) {
  if (Array.isArray(by)) {
    const byMap = {};
    for (const key of by) {
      byMap[key] = key;
    }
    return byMap;
  } else if (typeof by === "object") {
    return by;
  }
  return { [by]: by };
}
function isMatch(d, j, byMap) {
  for (const jKey in byMap) {
    const dKey = byMap[jKey];
    if (d[dKey] !== j[jKey]) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/@tidyjs/tidy/dist/es/leftJoin.js
function leftJoin(itemsToJoin, options) {
  const _leftJoin = (items) => {
    if (!itemsToJoin.length)
      return items;
    const byMap = (options == null ? void 0 : options.by) == null ? autodetectByMap(items, itemsToJoin) : makeByMap(options.by);
    const joinObjectKeys = Object.keys(itemsToJoin[0]);
    const joined = items.flatMap((d) => {
      const matches2 = itemsToJoin.filter((j) => isMatch(d, j, byMap));
      if (matches2.length) {
        return matches2.map((j) => ({ ...d, ...j }));
      }
      const undefinedFill = Object.fromEntries(joinObjectKeys.filter((key) => d[key] == null).map((key) => [key, void 0]));
      return { ...d, ...undefinedFill };
    });
    return joined;
  };
  return _leftJoin;
}

// ../../node_modules/@tidyjs/tidy/dist/es/mutateWithSummary.js
function mutateWithSummary(mutateSpec) {
  const _mutate = (items) => {
    const mutatedItems = items.map((d) => ({ ...d }));
    for (const key in mutateSpec) {
      const mutateSpecValue = mutateSpec[key];
      const mutatedResult = typeof mutateSpecValue === "function" ? mutateSpecValue(mutatedItems) : mutateSpecValue;
      const mutatedVector = (mutatedResult == null ? void 0 : mutatedResult[Symbol.iterator]) && typeof mutatedResult !== "string" ? mutatedResult : items.map(() => mutatedResult);
      let i = -1;
      for (const mutatedItem of mutatedItems) {
        mutatedItem[key] = mutatedVector[++i];
      }
    }
    return mutatedItems;
  };
  return _mutate;
}

// ../../node_modules/@tidyjs/tidy/dist/es/expand.js
function expand(expandKeys) {
  const _expand = (items) => {
    const keyMap = makeKeyMap(expandKeys);
    const vectors = [];
    for (const key in keyMap) {
      const keyValue = keyMap[key];
      let values;
      if (typeof keyValue === "function") {
        values = keyValue(items);
      } else if (Array.isArray(keyValue)) {
        values = keyValue;
      } else {
        values = Array.from(new Set(items.map((d) => d[key])));
      }
      vectors.push(values.map((value) => ({ [key]: value })));
    }
    return makeCombinations(vectors);
  };
  return _expand;
}
function makeCombinations(vectors) {
  function combine(accum, baseObj, remainingVectors) {
    if (!remainingVectors.length && baseObj != null) {
      accum.push(baseObj);
      return;
    }
    const vector = remainingVectors[0];
    const newRemainingArrays = remainingVectors.slice(1);
    for (const item of vector) {
      combine(accum, { ...baseObj, ...item }, newRemainingArrays);
    }
  }
  const result = [];
  combine(result, null, vectors);
  return result;
}
function makeKeyMap(keys) {
  if (Array.isArray(keys)) {
    const keyMap = {};
    for (const key of keys) {
      keyMap[key] = key;
    }
    return keyMap;
  } else if (typeof keys === "object") {
    return keys;
  }
  return { [keys]: keys };
}

// ../../node_modules/@tidyjs/tidy/dist/es/replaceNully.js
function replaceNully(replaceSpec) {
  const _replaceNully = (items) => {
    const replacedItems = [];
    for (const d of items) {
      const obj = { ...d };
      for (const key in replaceSpec) {
        if (obj[key] == null) {
          obj[key] = replaceSpec[key];
        }
      }
      replacedItems.push(obj);
    }
    return replacedItems;
  };
  return _replaceNully;
}

// ../../node_modules/@tidyjs/tidy/dist/es/complete.js
function complete(expandKeys, replaceNullySpec) {
  const _complete = (items) => {
    const expanded = expand(expandKeys)(items);
    const joined = leftJoin(items)(expanded);
    return replaceNullySpec ? replaceNully(replaceNullySpec)(joined) : joined;
  };
  return _complete;
}

// ../../node_modules/@tidyjs/tidy/dist/es/math/math.js
function rate(numerator, denominator, allowDivideByZero) {
  return numerator == null || denominator == null ? void 0 : denominator === 0 && numerator === 0 ? 0 : !allowDivideByZero && denominator === 0 ? void 0 : numerator / denominator;
}

// ../../node_modules/@tidyjs/tidy/dist/es/item/rate.js
function rate2(numerator, denominator, options) {
  const numeratorFn = typeof numerator === "function" ? numerator : (d) => d[numerator];
  const denominatorFn = typeof denominator === "function" ? denominator : (d) => d[denominator];
  const { predicate, allowDivideByZero } = options != null ? options : {};
  return predicate == null ? (d, index2, array2) => {
    const denom = denominatorFn(d, index2, array2);
    const numer = numeratorFn(d, index2, array2);
    return rate(numer, denom, allowDivideByZero);
  } : (d, index2, array2) => {
    if (!predicate(d, index2, array2))
      return void 0;
    const denom = denominatorFn(d, index2, array2);
    const numer = numeratorFn(d, index2, array2);
    return rate(numer, denom, allowDivideByZero);
  };
}

// ../../node_modules/@tidyjs/tidy/dist/es/helpers/summation.js
function mean2(items, accessor) {
  let n2 = 0;
  for (let i = 0; i < items.length; ++i) {
    const value = accessor(items[i], i, items);
    if (+value === value) {
      n2 += 1;
    }
  }
  return n2 ? fsum(items, accessor) / n2 : void 0;
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/min.js
function min2(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => min(items, keyFn);
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/max.js
function max2(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => max(items, keyFn);
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/mean.js
function mean3(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => mean2(items, keyFn);
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/median.js
function median(key) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => median_default(items, keyFn);
}

// ../../node_modules/@tidyjs/tidy/dist/es/summary/nDistinct.js
function nDistinct(key, options = {}) {
  const keyFn = typeof key === "function" ? key : (d) => d[key];
  return (items) => {
    const uniques = /* @__PURE__ */ new Map();
    let count3 = 0;
    let i = 0;
    for (const item of items) {
      const value = keyFn(item, i++, items);
      if (!uniques.has(value)) {
        if (!options.includeUndefined && value === void 0 || options.includeNull === false && value === null) {
          continue;
        }
        count3 += 1;
        uniques.set(value, true);
      }
    }
    return count3;
  };
}

// ../../node_modules/@evidence-dev/component-utilities/src/dateParsing.js
function standardizeDateString(date) {
  if (date && typeof date === "string") {
    let dateSplit = date.split(" ");
    if (!date.includes(":")) {
      date = date + "T00:00:00";
    }
    if (dateSplit.length > 2) {
      date = dateSplit[0] + " " + dateSplit[1];
    }
    const re = /\.([^\s]+)/;
    date = date.replace(re, "");
    date = date.replace("Z", "");
    date = date.replace(" ", "T");
  }
  return date;
}
function convertColumnToDate(data, column) {
  data = tidy(
    data,
    mutate({ [column]: (d) => d[column] ? new Date(standardizeDateString(d[column])) : null })
  );
  return data;
}
function standardizeDateColumn(data, column) {
  data = tidy(data, mutate({ [column]: (d) => standardizeDateString(d[column]) }));
  return data;
}

// ../../node_modules/@evidence-dev/component-utilities/src/inferColumnTypes.js
var EvidenceType;
(function(EvidenceType2) {
  EvidenceType2["BOOLEAN"] = "boolean";
  EvidenceType2["NUMBER"] = "number";
  EvidenceType2["STRING"] = "string";
  EvidenceType2["DATE"] = "date";
})(EvidenceType || (EvidenceType = {}));
var TypeFidelity;
(function(TypeFidelity2) {
  TypeFidelity2["INFERRED"] = "inferred";
  TypeFidelity2["PRECISE"] = "precise";
})(TypeFidelity || (TypeFidelity = {}));
var inferValueType = function(columnValue) {
  if (typeof columnValue === "number") {
    return EvidenceType.NUMBER;
  } else if (typeof columnValue === "boolean") {
    return EvidenceType.BOOLEAN;
  } else if (columnValue instanceof Date) {
    return EvidenceType.DATE;
  } else {
    return EvidenceType.STRING;
  }
};
function inferColumnTypes(rows) {
  if (rows == null ? void 0 : rows._evidenceColumnTypes) {
    return rows._evidenceColumnTypes;
  }
  if (rows && rows.length > 0) {
    let columns = Object.keys(rows[0]);
    let columnTypes = columns == null ? void 0 : columns.map((column) => {
      let firstRowWithColumnValue = rows.find(
        (element) => element[column] == null ? false : true
      );
      if (firstRowWithColumnValue) {
        let inferredType = inferValueType(firstRowWithColumnValue[column]);
        return { name: column, evidenceType: inferredType, typeFidelity: TypeFidelity.INFERRED };
      } else {
        return {
          name: column,
          evidenceType: EvidenceType.STRING,
          typeFidelity: TypeFidelity.INFERRED
        };
      }
    });
    return columnTypes;
  }
  return [];
}

// ../../node_modules/@evidence-dev/component-utilities/src/formatting.js
var AXIS_FORMATTING_CONTEXT = "axis";
var VALUE_FORMATTING_CONTEXT = "value";
var getCustomFormats = () => {
  var _a;
  try {
    return ((_a = getContext(CUSTOM_FORMATTING_SETTINGS_CONTEXT_KEY)) == null ? void 0 : _a.getCustomFormats()) || [];
  } catch (error) {
    return [];
  }
};
var lookupColumnFormat = (columnName, columnEvidenceType, columnUnitSummary) => {
  let potentialFormatTag = maybeExtractFormatTag(columnName);
  if (columnEvidenceType.evidenceType === "string") {
    return void 0;
  }
  if (potentialFormatTag) {
    let customFormats = getCustomFormats();
    let matchingFormat = [...BUILT_IN_FORMATS, ...customFormats].find(
      (format) => {
        var _a, _b;
        return ((_a = format.formatTag) == null ? void 0 : _a.toLowerCase()) === ((_b = potentialFormatTag == null ? void 0 : potentialFormatTag.toLowerCase) == null ? void 0 : _b.call(potentialFormatTag));
      }
    );
    if (matchingFormat) {
      return matchingFormat;
    }
  }
  let matchingImplicitAutoFormat = findImplicitAutoFormat(
    columnName,
    columnEvidenceType,
    columnUnitSummary
  );
  if (matchingImplicitAutoFormat) {
    return matchingImplicitAutoFormat;
  }
  return void 0;
};
function getFormatObjectFromString(formatString, valueType = void 0) {
  let potentialFormatTag = formatString;
  let customFormats = getCustomFormats();
  let matchingFormat = [...BUILT_IN_FORMATS, ...customFormats].find(
    (format) => {
      var _a, _b;
      return ((_a = format.formatTag) == null ? void 0 : _a.toLowerCase()) === ((_b = potentialFormatTag == null ? void 0 : potentialFormatTag.toLowerCase) == null ? void 0 : _b.call(potentialFormatTag));
    }
  );
  let newFormat = {};
  if (matchingFormat) {
    return matchingFormat;
  } else {
    newFormat = {
      formatTag: "custom",
      formatCode: potentialFormatTag
    };
    if (valueType) {
      newFormat.valueType = valueType;
    }
    return newFormat;
  }
}
var formatValue = (value, columnFormat = void 0, columnUnitSummary = void 0) => {
  try {
    return applyFormatting(value, columnFormat, columnUnitSummary, VALUE_FORMATTING_CONTEXT);
  } catch (error) {
    console.warn(
      `Unexpected error calling applyFormatting(${value}, ${columnFormat}, ${VALUE_FORMATTING_CONTEXT}, ${columnUnitSummary}). Error=${error}`
    );
    return value;
  }
};
var formatAxisValue = (value, columnFormat = void 0, columnUnitSummary = void 0) => {
  try {
    return applyFormatting(value, columnFormat, columnUnitSummary, AXIS_FORMATTING_CONTEXT);
  } catch (error) {
  }
  return value;
};
var applyTitleTagReplacement = (columnName, columnFormatSettings) => {
  let result = columnName;
  if (columnName && (columnFormatSettings == null ? void 0 : columnFormatSettings.formatTag)) {
    let lastIndexOfTag = columnName.toLowerCase().lastIndexOf(`_${columnFormatSettings.formatTag.toLowerCase()}`);
    let titleTagReplacement = "";
    if (lastIndexOfTag > 0) {
      if (typeof (columnFormatSettings == null ? void 0 : columnFormatSettings.titleTagReplacement) === "string") {
        titleTagReplacement = columnFormatSettings.titleTagReplacement;
      }
      result = columnName.substring(0, lastIndexOfTag) + titleTagReplacement;
    }
  }
  return result;
};
var defaultExample = (valueType) => {
  switch (valueType) {
    case "number":
      return 1234;
    case "date":
      return "2022-01-03";
    default:
      return void 0;
  }
};
var formatExample = (format) => {
  var _a, _b;
  let normalizedUserInput = (_a = format.userInput) == null ? void 0 : _a.trim();
  let preFormattedValue = normalizedUserInput || format.exampleInput || defaultExample(format.valueType);
  if (preFormattedValue) {
    try {
      let columnUnitSummary = void 0;
      if (format.valueType === "number") {
        let numericValue = Number(preFormattedValue);
        columnUnitSummary = {
          min: numericValue,
          max: numericValue,
          median: numericValue,
          maxDecimals: ((_b = numericValue.toString().split(".")[1]) == null ? void 0 : _b.length) || 0,
          unitType: "number"
        };
      }
      return applyFormatting(
        preFormattedValue,
        format,
        columnUnitSummary,
        VALUE_FORMATTING_CONTEXT
      );
    } catch (error) {
    }
  }
  return "";
};
function applyFormatting(value, columnFormat = void 0, columnUnitSummary = void 0, formattingContext = VALUE_FORMATTING_CONTEXT) {
  if (value === void 0 || value === null) {
    return "-";
  }
  let result = void 0;
  if (columnFormat) {
    try {
      let formattingCode = getEffectiveFormattingCode(columnFormat, formattingContext);
      let typedValue;
      try {
        if (columnFormat.valueType === "date" && typeof value === "string") {
          typedValue = new Date(standardizeDateString(value));
        } else if (value instanceof Date) {
          typedValue = new Date(value.toISOString().slice(0, -1));
        } else if (columnFormat.valueType === "number" && typeof value !== "number" && !Number.isNaN(value)) {
          typedValue = Number(value);
        } else {
          typedValue = value;
        }
      } catch (error) {
        typedValue = value;
      }
      if (isAutoFormat(columnFormat, formattingCode)) {
        try {
          result = autoFormat(typedValue, columnFormat, columnUnitSummary);
        } catch (error) {
          console.warn(`Unexpected error applying auto formatting. Error=${error}`);
        }
      } else {
        result = import_ssf3.default.format(formattingCode, typedValue);
      }
    } catch (error) {
      console.warn(`Unexpected error applying formatting ${error}`);
    }
  }
  if (result === void 0) {
    result = fallbackFormat(value, columnUnitSummary);
  }
  return result;
}
function getEffectiveFormattingCode(columnFormat, formattingContext = VALUE_FORMATTING_CONTEXT) {
  if (typeof columnFormat === "string") {
    return columnFormat;
  } else {
    if (formattingContext === AXIS_FORMATTING_CONTEXT && (columnFormat == null ? void 0 : columnFormat.axisFormatCode)) {
      return columnFormat.axisFormatCode;
    }
    return columnFormat == null ? void 0 : columnFormat.formatCode;
  }
}
function maybeExtractFormatTag(columnName) {
  let normalizedColName = columnName.toLowerCase();
  let lastUnderScoreIndex = normalizedColName.lastIndexOf("_");
  if (lastUnderScoreIndex > 0) {
    return normalizedColName.substr(lastUnderScoreIndex).replace("_", "");
  } else {
    return void 0;
  }
}
function fmt(value, format) {
  let formatObj = getFormatObjectFromString(format);
  let valueType = inferValueType(value);
  formatObj.valueType = valueType;
  return formatValue(value, formatObj);
}

export {
  require_ssf,
  SUPPORTED_CURRENCIES,
  BUILT_IN_FORMATS,
  tidy,
  summarize,
  summarizeAt,
  mutate,
  groupBy,
  n,
  sum2 as sum,
  rename,
  mutateWithSummary,
  replaceNully,
  complete,
  rate2 as rate,
  min2 as min,
  max2 as max,
  mean3 as mean,
  median,
  nDistinct,
  convertColumnToDate,
  standardizeDateColumn,
  EvidenceType,
  TypeFidelity,
  inferColumnTypes,
  getCustomFormats,
  lookupColumnFormat,
  getFormatObjectFromString,
  formatValue,
  formatAxisValue,
  applyTitleTagReplacement,
  defaultExample,
  formatExample,
  fmt
};
//# sourceMappingURL=chunk-POLSSDAJ.js.map
